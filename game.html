<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Catch the Missing Students</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            background-color: #1a1a1a; /* Fallback background */
            font-family: 'Press Start 2P', cursive;
            color: #fff;
            overflow: hidden; /* Prevent scrollbars */
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #gameCanvas {
            border: none; /* Removed border for full screen feel */
            background-color: #2c2c2c; /* Initial canvas background */
            display: block;
            max-width: 100%; /* Ensure canvas doesn't overflow */
            max-height: 100%; /* Ensure canvas doesn't overflow */
            object-fit: contain; 
        }
        #gameUI { /* This is the temporary message box */
            position: absolute;
            top: 20px; /* Adjusted top for better visibility */
            left: 50%; 
            transform: translateX(-50%); 
            padding: 10px 15px;
            background-color: rgba(0,0,0,0.8); 
            border-radius: 8px;
            font-size: clamp(0.7em, 2.5vw, 1em); 
            color: #ffcc00;
            z-index: 100; /* Ensure it's above game UI like joystick */
            pointer-events: none;
            max-width: 90%; 
            text-align: center;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="gameUI" class="hidden">Press WASD or Arrow Keys to move</div>
    <script>
        // --- Canvas and Context ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameUIMessage = document.getElementById('gameUI'); 

        // --- Mobile Detection & Fullscreen ---
        const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0);
        let isFullscreenActive = false;
        let screenEdgePadding = 0; 

        // --- Game Settings ---
        const TILE_SIZE = 20; 
        const WORLD_WIDTH = TILE_SIZE * 100;
        const WORLD_HEIGHT = TILE_SIZE * 80;
        const DETECTION_RADIUS = TILE_SIZE * 8;
        const ESCAPE_RADIUS = TILE_SIZE * 5;
        const CAPTURE_RADIUS = TILE_SIZE * 0.8;
        let gameTime = 0; 
        let gamePaused = false;
        let currentDay = 1;

        // --- Day Cycle Variables ---
        const GAME_DAY_START_HOUR = 6.5; 
        const GAME_DAY_END_HOUR = 13.0;  
        const GAME_DAY_DURATION_HOURS = GAME_DAY_END_HOUR - GAME_DAY_START_HOUR; 
        const FADE_SPEED = 0.02; 
        let fadeOverlayAlpha = 0;


        // --- Camera ---
        const camera = {
            x: 0, y: 0,
            width: canvas.width,
            height: canvas.height,
            zoom: 1 
        };

        // --- Characters and Objects ---
        const player = {
            name: "Kremer",
            x: WORLD_WIDTH / 2, y: WORLD_HEIGHT / 2,
            width: TILE_SIZE, height: TILE_SIZE,
            color: '#007bff', 
            baseSpeed: 25, 
            currentSpeed: 25,
            sprintMultiplier: 1.8, 
            targetX: WORLD_WIDTH / 2, targetY: WORLD_HEIGHT / 2,
            dx: 0, dy: 0,
            movementSmoothing: 0.2,
            stamina: 100, maxStamina: 100,
            staminaRegenRate: 0.5, staminaDepletionRate: 0.8,
            isSprinting: false, 
            captureCount: 0, 
            radarActive: false,
            attractionField: false, attractionRadius: 0, attractionForce: 0
        };

        const ziv = {
            name: "Ziv",
            x: TILE_SIZE * 80, y: TILE_SIZE * 10,
            width: TILE_SIZE, height: TILE_SIZE,
            color: '#6f42c1'
        };
        
        const tables = [
            {
                id: "kremer_table", 
                name: "Class Table",
                x: TILE_SIZE * 5, y: WORLD_HEIGHT - TILE_SIZE * 15,
                width: TILE_SIZE * 10, height: TILE_SIZE * 4,
                color: '#6c757d',
                isBench: false
            },
            {
                id: "ziv_table", 
                name: "Ziv's Table",
                x: ziv.x - TILE_SIZE * 4, y: ziv.y + TILE_SIZE * 2,
                width: TILE_SIZE * 8, height: TILE_SIZE * 3,
                color: '#5c656d',
                isBench: false
            }
        ];

        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        
        const tableColors = ['#8B4513', '#A0522D', '#803515', '#975429'];
        const benchColor = '#A0522D'; 
        const benchThickness = TILE_SIZE * 0.75;
        const benchOffset = TILE_SIZE * 0.2;

        for (let i = 0; i < 15; i++) {
            const tableWidth = getRandomInt(3, 8) * TILE_SIZE;
            const tableHeight = getRandomInt(2, 5) * TILE_SIZE;
            let tableX, tableY, validPosition;
            do {
                validPosition = true;
                tableX = getRandomInt(TILE_SIZE * 5, WORLD_WIDTH - tableWidth - TILE_SIZE * 5);
                tableY = getRandomInt(TILE_SIZE * 5, WORLD_HEIGHT - tableHeight - TILE_SIZE * 5);
                for (const existingTable of tables) {
                    const combinedHalfWidths = (tableWidth + existingTable.width) / 2 + TILE_SIZE * 2; 
                    const combinedHalfHeights = (tableHeight + existingTable.height) / 2 + TILE_SIZE * 2;
                    if (Math.abs((tableX + tableWidth/2) - (existingTable.x + existingTable.width/2)) < combinedHalfWidths &&
                        Math.abs((tableY + tableHeight/2) - (existingTable.y + existingTable.height/2)) < combinedHalfHeights) {
                        validPosition = false;
                        break;
                    }
                }
            } while (!validPosition);
            
            const mainTable = {
                id: `dining_table_${i}`,
                name: "Dining Table", 
                x: tableX, y: tableY, width: tableWidth, height: tableHeight,
                color: tableColors[getRandomInt(0, tableColors.length -1)],
                isBench: false 
            };
            tables.push(mainTable);

            if (tableWidth > tableHeight) { 
                tables.push({
                    id: `dining_table_${i}_bench_top`, name: "Bench", 
                    x: tableX, y: tableY - benchThickness - benchOffset,
                    width: tableWidth, height: benchThickness,
                    color: benchColor, isBench: true 
                });
                tables.push({
                    id: `dining_table_${i}_bench_bottom`, name: "Bench",
                    x: tableX, y: tableY + tableHeight + benchOffset,
                    width: tableWidth, height: benchThickness,
                    color: benchColor, isBench: true
                });
            } else { 
                tables.push({
                    id: `dining_table_${i}_bench_left`, name: "Bench",
                    x: tableX - benchThickness - benchOffset, y: tableY,
                    width: benchThickness, height: tableHeight,
                    color: benchColor, isBench: true
                });
                tables.push({
                    id: `dining_table_${i}_bench_right`, name: "Bench",
                    x: tableX + tableWidth + benchOffset, y: tableY,
                    width: benchThickness, height: tableHeight,
                    color: benchColor, isBench: true
                });
            }
        }


        const KREMER_TABLE_INDEX = 0; 
        const ZIV_TABLE_INDEX = 1;   

        const kremerStudentNames = [
            "Itamar", "Noam", "Moshe", "Yossi", "Shachar", "Oryan", "Naor", "Adiel", "Elisha", "Benjamin",
            "Avi", "Ron", "Gal", "Liran", "Yaniv" // Total 15 names
        ];
        const zivStudentNames = [
            "Gershy", "Shua", "Rafi", "Orel", "Yair", "Ehuvia", 
            "Eliel", "Elad", "Dvir", "Arbel", "Hagi", "Nachshon" // Total 12 names
        ];


        const students = []; 
        const zivStudents = []; 

        const KREMER_STUDENT_COLOR = '#28a745'; 
        const ZIV_STUDENT_COLOR = '#FFA500';   


        const powerUps = [];
        const powerUpTypes = [
            {
                name: "Speed Boost", color: "#ffcc00",
                effect: () => {
                    const originalBaseSpeed = player.baseSpeed; 
                    player.baseSpeed *= 1.5; 
                    showGameMessage("Speed Boost Active!");
                    setTimeout(() => {
                        player.baseSpeed = originalBaseSpeed; 
                        showGameMessage("Speed boost ended!");
                    }, 5000); 
                }
            },
            {
                name: "Student Freeze", color: "#00ccff",
                effect: () => {
                    students.forEach(s => { if (!s.isCaught) s.frozenTimer = 5 * 60; }); 
                    showGameMessage("Student Freeze active!");
                }
            },
            {
                name: "Attraction Field", color: "#ff00cc",
                effect: () => {
                    player.attractionField = true;
                    player.attractionRadius = TILE_SIZE * 10;
                    player.attractionForce = 0.5;
                    showGameMessage("Attraction Field active!");
                    setTimeout(() => {
                        player.attractionField = false;
                        showGameMessage("Attraction field deactivated!");
                    }, 7000);
                }
            },
            {
                name: "Stamina Refill", color: "#00ff00",
                effect: () => {
                    player.stamina = player.maxStamina;
                    showGameMessage("Stamina Refilled!");
                }
            }
        ];

        const environment = {
            timeOfDay: 0, 
            dayLengthInSeconds: 60, 
            updateEnvironment: function() {
                if (gamePaused || gameStates.isTransitioningDay()) return;
                gameTime += 1/60; 
                this.timeOfDay = Math.min(1, gameTime / this.dayLengthInSeconds);
                if (this.timeOfDay >= 1 && !gameStates.isTransitioningDay()) {
                    gameStates.startDayTransition();
                }
            },
            getBackgroundColor: function() {
                let skyColor;
                const progress = this.timeOfDay;
                if (progress < 0.1) { 
                    const t = progress / 0.1;
                    skyColor = `rgb(${Math.floor(80 + t * 50)}, ${Math.floor(100 + t * 80)}, ${Math.floor(150 + t * 85)})`;
                } else if (progress < 0.8) { 
                    skyColor = '#87CEEB'; 
                } else { 
                    const t = (progress - 0.8) / 0.2;
                    skyColor = `rgb(${Math.floor(135 - t * 30)}, ${Math.floor(206 - t * 20)}, ${Math.floor(235 - t * 10)})`;
                }
                return skyColor;
            },
            getLightLevel: function() {
                const progress = this.timeOfDay; 
                if (progress < 0.1) return 0.8 + progress * 2; 
                else if (progress < 0.8) return 1.0;        
                else return 1.0 - (progress - 0.8) * 1;     
            }
        };

        const specialAbilities = {
            active: false, cooldown: 0, maxCooldown: 600, 
            timeWarpEffectActive: false, // Flag for visual effect
            available: [
                {
                    name: "Time Warp", description: "Slow down time for everyone except you.",
                    activate: function() {
                        const slowFactor = 0.3;
                        const originalSpeeds = [];
                        students.forEach((s, i) => {
                            originalSpeeds[i] = { speed: s.speed, runSpeed: s.runSpeed, returnSpeed: s.returnSpeed };
                            s.speed *= slowFactor; s.runSpeed *= slowFactor; s.returnSpeed *= slowFactor;
                        });
                        showGameMessage("Time Warp active!");
                        specialAbilities.timeWarpEffectActive = true; 
                        setTimeout(() => { 
                            students.forEach((s, i) => {
                                if (originalSpeeds[i]) { 
                                    s.speed = originalSpeeds[i].speed;
                                    s.runSpeed = originalSpeeds[i].runSpeed;
                                    s.returnSpeed = originalSpeeds[i].returnSpeed;
                                }
                            });
                            showGameMessage("Time Warp ended");
                            specialAbilities.timeWarpEffectActive = false;
                            specialAbilities.active = false;
                            specialAbilities.cooldown = specialAbilities.maxCooldown;
                        }, 2500); 
                    }
                },
                {
                    name: "Super Sprint", description: "Infinite stamina and doubled speed for a short time.",
                    activate: function() {
                        const originalSpeed = player.baseSpeed;
                        player.baseSpeed *= 2; player.stamina = player.maxStamina; 
                        showGameMessage("Super Sprint active!");
                        setTimeout(() => {
                            player.baseSpeed = originalSpeed;
                            showGameMessage("Super Sprint ended");
                            specialAbilities.active = false;
                            specialAbilities.cooldown = specialAbilities.maxCooldown;
                        }, 7000); 
                    }
                },
                {
                    name: "Student Radar", description: "Reveal the positions of Kremer's students.",
                    activate: function() {
                        player.radarActive = true; 
                        showGameMessage("Student Radar active!");
                        setTimeout(() => {
                            player.radarActive = false;
                            showGameMessage("Student Radar ended");
                            specialAbilities.active = false;
                            specialAbilities.cooldown = specialAbilities.maxCooldown;
                        }, 12000); 
                    }
                }
            ],
            selectedAbility: 0,
            update: function() {
                if (gamePaused || gameStates.isTransitioningDay()) return;
                if (this.cooldown > 0) this.cooldown--;
            },
            activateAbility: function() {
                if (gamePaused || gameStates.isTransitioningDay()) return;
                if (this.cooldown === 0 && !this.active) {
                    this.active = true; this.available[this.selectedAbility].activate();
                } else if (this.cooldown > 0) {
                    showGameMessage(`Ability on cooldown: ${Math.ceil(this.cooldown / 60)}s`);
                } else if (this.active){
                    showGameMessage(`Ability already active!`);
                }
            },
            cycleAbility: function() {
                if (gamePaused || this.active || gameStates.isTransitioningDay()) return; 
                this.selectedAbility = (this.selectedAbility + 1) % this.available.length;
                showGameMessage(`Selected: ${this.available[this.selectedAbility].name}`);
            }
        };
        
        const gameStates = {
            MENU: 'menu', GAME: 'game', PAUSED: 'paused',
            GAME_OVER: 'gameOver', VICTORY: 'victory', INSTRUCTIONS: 'instructions',
            DAY_TRANSITION_OUT: 'dayTransitionOut', DAY_TRANSITION_IN: 'dayTransitionIn',
            currentState: 'menu',
            startScreen: {
                title: "Catch The Students!",
                subtitle: "Can you bring them all back to class?",
                options: [
                    { text: "Start Game", action: () => gameStates.startGame() },
                    { text: "How to Play", action: () => gameStates.showInstructionsScreen() }
                ],
                selectedOption: 0,
                fullscreenButtonRect: null, 
                draw: function() {
                    ctx.fillStyle = '#2c2c2c'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#fff'; 
                    ctx.font = `${Math.min(32, canvas.width / 18, canvas.height / 15)}px "Press Start 2P"`; 
                    ctx.textAlign = 'center';
                    ctx.fillText(this.title, canvas.width / 2, canvas.height / 3);
                    ctx.font = `${Math.min(16, canvas.width / 30, canvas.height / 25)}px "Press Start 2P"`;
                    ctx.fillText(this.subtitle, canvas.width / 2, canvas.height / 3 + Math.min(40, canvas.height / 10));
                    ctx.font = `${Math.min(20, canvas.width / 25, canvas.height / 20)}px "Press Start 2P"`;
                    this.options.forEach((option, i) => {
                        ctx.fillStyle = (i === this.selectedOption) ? '#ffcc00' : '#fff';
                        ctx.fillText((i === this.selectedOption ? '> ' : '') + option.text + (i === this.selectedOption ? ' <' : ''), canvas.width / 2, canvas.height / 2 + i * Math.min(50, canvas.height / 10) + Math.min(30, canvas.height / 15));
                    });
                    ctx.font = `${Math.min(12, canvas.width / 40, canvas.height / 35)}px "Press Start 2P"`; ctx.fillStyle = '#aaa';
                    ctx.fillText('Navigate: Keys/Touch, Select: Enter/Tap', canvas.width / 2, canvas.height - Math.min(50, canvas.height / 8));

                    if (isTouchDevice) {
                        const fsBtnSize = Math.min(canvas.width, canvas.height) * 0.06;
                        const fsBtnPadding = Math.min(15, canvas.width * 0.03);
                        const fsBtnX = canvas.width - fsBtnSize - fsBtnPadding;
                        const fsBtnY = fsBtnPadding;
                        this.fullscreenButtonRect = {x: fsBtnX, y: fsBtnY, width: fsBtnSize, height: fsBtnSize};
                        drawRect(fsBtnX, fsBtnY, fsBtnSize, fsBtnSize, isFullscreenActive ? 'rgba(80,80,80,0.7)' : 'rgba(120,120,120,0.7)');
                        drawText(isFullscreenActive ? '[ ]' : 'FS', fsBtnX + fsBtnSize/2, fsBtnY + fsBtnSize/2 + fsBtnSize*0.1, '#fff', fsBtnSize*0.4);
                    }
                },
                handleInput: function(key) {
                    switch(key.toLowerCase()) {
                        case 'arrowup': case 'w': this.selectedOption = Math.max(0, this.selectedOption - 1); break;
                        case 'arrowdown': case 's': this.selectedOption = Math.min(this.options.length - 1, this.selectedOption + 1); break;
                        case 'enter': case ' ': this.options[this.selectedOption].action(); break;
                    }
                }
            },
            instructionsScreen: {
                draw: function() {
                    ctx.fillStyle = '#2c2c2c'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#fff'; 
                    ctx.font = `${Math.min(24, canvas.width / 20, canvas.height / 18)}px "Press Start 2P"`; 
                    ctx.textAlign = 'center';
                    ctx.fillText("How to Play", canvas.width / 2, Math.min(80, canvas.height/8));
                    ctx.font = `${Math.min(11, canvas.width / 45, canvas.height / 30)}px "Press Start 2P"`; 
                    ctx.textAlign = 'left';
                    const instructionsText = [
                        "Desktop Controls:",
                        "- WASD or Arrow Keys: Move", 
                        "- SHIFT: Sprint (uses stamina)",
                        "- SPACE: Use Special Ability", 
                        "- Q: Cycle Special Ability",
                        "- P: Pause Game",
                        "",
                        "Mobile Controls (Landscape):",
                        "- Left Joystick: Move",
                        "- Bottom-Right Buttons:",
                        "  'RUN': Hold to Sprint",
                        "  'USE': Activate Ability",
                        "  'SWAP': Cycle Ability",
                        "",
                        "Goal: Catch all Kremer's students before 13:00!",
                        "Students get bored at their desks and might leave.",
                        "Catching them repeatedly makes them mad!",
                        "A new day starts if time runs out."
                    ];
                    const lineHeight = Math.min(22, canvas.height / 22);
                    const startY = Math.min(120, canvas.height / 6);
                    const startX = canvas.width / 10;
                    instructionsText.forEach((text, i) => ctx.fillText(text, startX, startY + i * lineHeight));
                    ctx.fillStyle = '#ffcc00'; ctx.textAlign = 'center'; 
                    ctx.font = `${Math.min(16, canvas.width / 30, canvas.height / 25)}px "Press Start 2P"`;
                    ctx.fillText("Tap or Press ESC/Enter to Return", canvas.width / 2, canvas.height - Math.min(50, canvas.height / 10));
                },
                handleInput: function(key) {
                    if (['escape', 'enter', ' '].includes(key.toLowerCase())) {
                        gameStates.currentState = gameStates.MENU;
                    }
                }
            },
            pauseMenu: { 
                options: [
                    { text: "Resume", action: () => { gameStates.currentState = gameStates.GAME; gamePaused = false; } },
                    { text: "Restart Day", action: () => gameStates.restartCurrentDay() }, 
                    { text: "Main Menu", action: () => { gameStates.currentState = gameStates.MENU; gamePaused = false; gameTime = 0; currentDay = 1;} }
                ],
                selectedOption: 0,
                draw: function() {
                    drawGame(); 
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#fff'; 
                    ctx.font = `${Math.min(32, canvas.width / 18, canvas.height / 15)}px "Press Start 2P"`; 
                    ctx.textAlign = 'center';
                    ctx.fillText("PAUSED", canvas.width / 2, canvas.height / 3);
                    ctx.font = `${Math.min(20, canvas.width / 25, canvas.height / 20)}px "Press Start 2P"`;
                    this.options.forEach((option, i) => {
                        ctx.fillStyle = (i === this.selectedOption) ? '#ffcc00' : '#fff';
                        ctx.fillText((i === this.selectedOption ? '> ' : '') + option.text + (i === this.selectedOption ? ' <' : ''), canvas.width / 2, canvas.height / 2 + i * Math.min(50, canvas.height / 10));
                    });
                },
                handleInput: function(key) {
                    switch(key.toLowerCase()) {
                        case 'arrowup': case 'w': this.selectedOption = Math.max(0, this.selectedOption - 1); break;
                        case 'arrowdown': case 's': this.selectedOption = Math.min(this.options.length - 1, this.selectedOption + 1); break;
                        case 'enter': case ' ': this.options[this.selectedOption].action(); break;
                        case 'escape': case 'p': gameStates.currentState = gameStates.GAME; gamePaused = false; break;
                    }
                }
            },
            gameOverScreen: { 
                draw: function() { /* Not used directly, VICTORY is the end state */ },
                handleInput: function(key) { /* ... */ }
            },
            victoryScreen: { 
                draw: function() {
                    ctx.fillStyle = 'rgba(0, 0, 100, 0.3)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#fff';
                    for (let i = 0; i < 50; i++) { 
                        const x = (Math.sin(i * 0.1 + Date.now() * 0.0002) * 0.4 + 0.5) * canvas.width; 
                        const y = (Math.cos(i * 0.1 + Date.now() * 0.0002) * 0.4 + 0.5) * canvas.height;
                        const size = Math.sin(i + Date.now() * 0.002) * 1.5 + 2; 
                        if (size > 0) ctx.fillRect(x, y, size, size);
                    }
                    ctx.shadowColor = '#ffff00'; ctx.shadowBlur = 15; ctx.fillStyle = '#ffff00';
                    ctx.font = `${Math.min(36, canvas.width / 15, canvas.height / 12)}px "Press Start 2P"`; 
                    ctx.textAlign = 'center';
                    ctx.fillText("VICTORY!", canvas.width / 2, canvas.height / 3);
                    ctx.shadowBlur = 0; ctx.fillStyle = '#fff'; 
                    ctx.font = `${Math.min(20, canvas.width / 25, canvas.height / 20)}px "Press Start 2P"`;
                    ctx.fillText(`All of Kremer's students captured!`, canvas.width / 2, canvas.height / 2 - Math.min(20, canvas.height/20) );
                    ctx.fillText(`It took you ${currentDay} day(s).`, canvas.width / 2, canvas.height / 2 + Math.min(20, canvas.height/20));
                    ctx.fillStyle = '#ffcc00'; 
                    ctx.font = `${Math.min(16, canvas.width / 30, canvas.height / 25)}px "Press Start 2P"`;
                    ctx.fillText("Tap or Press ENTER for Main Menu", canvas.width / 2, canvas.height / 2 + Math.min(100, canvas.height/6));
                },
                handleInput: function(key) {
                    switch(key.toLowerCase()) {
                        case 'enter': case ' ': gameStates.currentState = gameStates.MENU; gameTime = 0; currentDay = 1; break;
                        case 'escape': gameStates.currentState = gameStates.MENU; gameTime = 0; currentDay = 1; break;
                    }
                }
            },
            isTransitioningDay: function() {
                return this.currentState === this.DAY_TRANSITION_OUT || this.currentState === this.DAY_TRANSITION_IN;
            },
            startDayTransition: function() {
                if (this.isTransitioningDay()) return;
                this.currentState = this.DAY_TRANSITION_OUT;
                gamePaused = true; 
                showGameMessage("End of the day...", 3000); 
            },
            resetDay: function() {
                gameTime = 0; 
                environment.timeOfDay = 0;
                player.x = tables[KREMER_TABLE_INDEX].x + tables[KREMER_TABLE_INDEX].width / 2;
                player.y = tables[KREMER_TABLE_INDEX].y + tables[KREMER_TABLE_INDEX].height + TILE_SIZE * 2;
                player.targetX = player.x; player.targetY = player.y;
                player.stamina = player.maxStamina; 
                
                const previouslyCaughtKremerStudentNames = students.filter(s => s.isCaught).map(s => s.name);
                
                initializeAllStudents(); 
                
                students.forEach(s => { 
                    s.timesCaughtThisDay = 0; 
                    if (previouslyCaughtKremerStudentNames.includes(s.name)) {
                        s.isCaught = true;
                        s.isAtSeat = true;
                        s.x = s.seatX; 
                        s.y = s.seatY;
                        s.boredom = 0; 
                    } else {
                        s.isCaught = false;
                        s.isAtSeat = false;
                    }
                });
                player.captureCount = students.filter(s => s.isCaught && s.isAtSeat).length;


                spawnPowerUps();
                updateCamera();
            },
            startGame: function() { 
                currentDay = 1;
                player.captureCount = 0; 
                initializeAllStudents(); 
                this.resetDay(); 
                this.currentState = this.GAME; 
                gamePaused = false;
                fadeOverlayAlpha = 0; 
                specialAbilities.cooldown = 0; specialAbilities.active = false; specialAbilities.selectedAbility = 0;
                showGameMessage(`Day ${currentDay}: Catch the students!`);
                if (isTouchDevice) setupMobileControls();
            },
            restartCurrentDay: function() { 
                const currentCaughtCount = player.captureCount; 
                const caughtNames = students.filter(s => s.isCaught).map(s => s.name);

                this.resetDay(); 
                
                let newCaptureCount = 0;
                students.forEach(s => {
                    if (caughtNames.includes(s.name)) {
                        s.isCaught = true;
                        s.isAtSeat = true;
                        s.x = s.seatX;
                        s.y = s.seatY;
                        s.boredom = 0;
                        s.happiness = 50; 
                        s.madness = 0;
                        s.timesCaughtThisDay = 0; 
                        newCaptureCount++;
                    }
                });
                player.captureCount = newCaptureCount;


                this.currentState = this.GAME;
                gamePaused = false;
                fadeOverlayAlpha = 0;
                showGameMessage(`Restarting Day ${currentDay}`);
            },
            showInstructionsScreen: function() { this.currentState = this.INSTRUCTIONS; },
            handleKeyPress: function(key) { 
                switch(this.currentState) {
                    case this.MENU: this.startScreen.handleInput(key); break;
                    case this.INSTRUCTIONS: this.instructionsScreen.handleInput(key); break;
                    case this.PAUSED: this.pauseMenu.handleInput(key); break;
                    case this.VICTORY: this.victoryScreen.handleInput(key); break;
                }
            },
            update: function() { 
                if (this.currentState === this.GAME && !gamePaused) {
                    const allKremerStudentsCaughtAndAtSeat = students.length > 0 && students.every(s => s.isCaught && s.isAtSeat);
                    if (allKremerStudentsCaughtAndAtSeat) {
                        this.currentState = this.VICTORY; 
                        player.dx = 0; player.dy = 0; 
                        keys.up = keys.down = keys.left = keys.right = keys.shift = false;
                        if (isTouchDevice && joystick.active) {
                            joystick.active = false; joystick.touchId = null;
                            joystick.stickX = joystick.x; joystick.stickY = joystick.y;
                        }
                    }
                } else if (this.currentState === this.DAY_TRANSITION_OUT) {
                    fadeOverlayAlpha += FADE_SPEED;
                    if (fadeOverlayAlpha >= 1) {
                        fadeOverlayAlpha = 1;
                        currentDay++; 
                        this.resetDay(); 
                        showGameMessage(`Day ${currentDay}`, 3000);
                        this.currentState = this.DAY_TRANSITION_IN;
                    }
                } else if (this.currentState === this.DAY_TRANSITION_IN) {
                    fadeOverlayAlpha -= FADE_SPEED;
                    if (fadeOverlayAlpha <= 0) {
                        fadeOverlayAlpha = 0;
                        this.currentState = this.GAME;
                        gamePaused = false; 
                    }
                }
            },
            draw: function() { 
                switch(this.currentState) {
                    case this.MENU: this.startScreen.draw(); break;
                    case this.INSTRUCTIONS: this.instructionsScreen.draw(); break;
                    case this.PAUSED: this.pauseMenu.draw(); break; 
                    case this.VICTORY: this.victoryScreen.draw(); break;
                }
            }
        };
        
        function showGameMessage(message, duration = 2000) {
            gameUIMessage.textContent = message;
            gameUIMessage.classList.remove('hidden');
            setTimeout(() => {
                if (gameUIMessage.textContent === message) { 
                    gameUIMessage.classList.add('hidden');
                }
            }, duration);
        }


        function distance(obj1, obj2) {
            const centerX1 = obj1.x + obj1.width / 2; const centerY1 = obj1.y + obj1.height / 2;
            const centerX2 = obj2.x + obj2.width / 2; const centerY2 = obj2.y + obj2.height / 2;
            return Math.sqrt(Math.pow(centerX1 - centerX2, 2) + Math.pow(centerY1 - centerY2, 2));
        }

        function generateSeatPositions(tableIndex, numSeats) {
            const table = tables[tableIndex]; 
            const seats = [];
            const spacing = TILE_SIZE * 1.5;
        
            for (let i = 0; i < Math.floor(table.width / spacing) && seats.length < numSeats; i++) {
                seats.push({ x: table.x + i * spacing + TILE_SIZE * 0.25, y: table.y - TILE_SIZE * 1.5 });
            }
            for (let i = 0; i < Math.floor(table.height / spacing) && seats.length < numSeats; i++) {
                seats.push({ x: table.x + table.width + TILE_SIZE, y: table.y + i * spacing + TILE_SIZE * 0.25 });
            }
            for (let i = 0; i < Math.floor(table.width / spacing) && seats.length < numSeats; i++) {
                seats.push({ x: table.x + i * spacing + TILE_SIZE * 0.25, y: table.y + table.height + TILE_SIZE * 0.5 });
            }
            for (let i = 0; i < Math.floor(table.height / spacing) && seats.length < numSeats; i++) {
                seats.push({ x: table.x - TILE_SIZE * 1.5, y: table.y + i * spacing + TILE_SIZE * 0.25 });
            }
            while (seats.length < numSeats) { // Fallback for tables too small for regular spacing
                 const randomSide = getRandomInt(0,3);
                 if (randomSide === 0) seats.push({ x: table.x + getRandomInt(0, Math.floor(table.width/TILE_SIZE)-1) * TILE_SIZE, y: table.y - TILE_SIZE * 1.5 });
                 else if (randomSide === 1) seats.push({ x: table.x + table.width + TILE_SIZE, y: table.y + getRandomInt(0, Math.floor(table.height/TILE_SIZE)-1) * TILE_SIZE });
                 else if (randomSide === 2) seats.push({ x: table.x + getRandomInt(0, Math.floor(table.width/TILE_SIZE)-1) * TILE_SIZE, y: table.y + table.height + TILE_SIZE * 0.5 });
                 else seats.push({ x: table.x - TILE_SIZE * 1.5, y: table.y + getRandomInt(0, Math.floor(table.height/TILE_SIZE)-1) * TILE_SIZE });
            }
            return seats.slice(0, numSeats);
        }

        const kremerSeatPositions = generateSeatPositions(KREMER_TABLE_INDEX, 15); 
        const zivSeatPositions = generateSeatPositions(ZIV_TABLE_INDEX, Math.min(6, zivStudentNames.length)); // Max 6 visual seats for Ziv


        function findKremerStudentValidPositions(count) {
            const positions = []; const minDistanceBetweenStudents = TILE_SIZE * 3;
            const kremerTable = tables[KREMER_TABLE_INDEX];
            const playerStartX = kremerTable.x + kremerTable.width / 2;
            const playerStartY = kremerTable.y + kremerTable.height + TILE_SIZE * 2;

            for (let i = 0; i < count; i++) {
                let studentX, studentY, validPosition; let attempts = 0;
                do {
                    attempts++; validPosition = true;
                    studentX = getRandomInt(TILE_SIZE * 2, WORLD_WIDTH - TILE_SIZE * 3);
                    studentY = getRandomInt(TILE_SIZE * 2, WORLD_HEIGHT - TILE_SIZE * 3);
                    for (const table of tables) if (checkCollision({x: studentX - TILE_SIZE, y: studentY - TILE_SIZE, width: TILE_SIZE * 3, height: TILE_SIZE * 3}, table)) { validPosition = false; break; }
                    if (validPosition) for (const pos of positions) if (Math.sqrt(Math.pow(studentX - pos.x, 2) + Math.pow(studentY - pos.y, 2)) < minDistanceBetweenStudents) { validPosition = false; break; }
                    if (Math.sqrt(Math.pow(studentX - playerStartX, 2) + Math.pow(studentY - playerStartY, 2)) < TILE_SIZE * 15) validPosition = false;
                    if (tables[ZIV_TABLE_INDEX] && checkCollision({x: studentX, y: studentY, width: TILE_SIZE, height: TILE_SIZE}, tables[ZIV_TABLE_INDEX])) validPosition = false; 
                    if (attempts > 200) { 
                        studentX = getRandomInt(TILE_SIZE, WORLD_WIDTH - TILE_SIZE * 2); 
                        studentY = getRandomInt(TILE_SIZE, WORLD_HEIGHT - TILE_SIZE * 2); 
                        break; 
                    }
                } while (!validPosition);
                positions.push({x: studentX, y: studentY});
            }
            return positions;
        }
        
        function initializeKremerStudents() {
            students.length = 0; 
            const numStudentsToSpawn = 15; 
            const validPositions = findKremerStudentValidPositions(numStudentsToSpawn);

            for (let i = 0; i < numStudentsToSpawn; i++) {
                students.push({
                    id: `kremer_${i}`, name: kremerStudentNames[i % kremerStudentNames.length], teacher: "Kremer", 
                    x: validPositions[i].x, y: validPositions[i].y,
                    width: TILE_SIZE, height: TILE_SIZE,
                    color: KREMER_STUDENT_COLOR, 
                    isCaught: false, isAtSeat: false,
                    isWandering: true, isAfraidOfTeacher: false,
                    wanderTargetX: validPositions[i].x, wanderTargetY: validPositions[i].y,
                    seatX: kremerSeatPositions[i % kremerSeatPositions.length].x, 
                    seatY: kremerSeatPositions[i % kremerSeatPositions.length].y,
                    speed: 1.5 + Math.random() * 0.5, runSpeed: 2.5 + Math.random() * 0.7, returnSpeed: 3,
                    wanderTimer: 0, wanderDelay: getRandomInt(60, 200), 
                    lastDirection: { x: 0, y: 0 },
                    personality: { bravery: Math.random() * 0.6 + 0.2, intelligence: Math.random() * 0.7 + 0.1, stubbornness: Math.random() },
                    escapeTimer: 0, escapeFailCounter: 0, messageTimer: 0, currentMessage: "", frozenTimer: 0,
                    happiness: 50, madness: 0, boredom: 0, timesCaughtThisDay: 0
                });
            }
        }

        function initializeZivStudents() {
            zivStudents.length = 0;
            const zivTable = tables[ZIV_TABLE_INDEX];
            
            for (let i = 0; i < zivStudentNames.length; i++) {
                let studentX, studentY, isWanderingZ; 
                const studentSpeed = 0.7; 
                let currentSeatX = null;
                let currentSeatY = null;

                if (i < zivSeatPositions.length) { 
                    isWanderingZ = false;
                    currentSeatX = zivSeatPositions[i].x; 
                    currentSeatY = zivSeatPositions[i].y;
                    studentX = currentSeatX;
                    studentY = currentSeatY;
                } else { 
                    isWanderingZ = true;
                    studentX = zivTable.x + zivTable.width / 2 + getRandomInt(-TILE_SIZE * 4, TILE_SIZE * 4); // Wider wander start for Ziv
                    studentY = zivTable.y + zivTable.height / 2 + getRandomInt(-TILE_SIZE * 4, TILE_SIZE * 4);
                }
                
                studentX = Math.max(TILE_SIZE, Math.min(studentX, WORLD_WIDTH - TILE_SIZE*2));
                studentY = Math.max(TILE_SIZE, Math.min(studentY, WORLD_HEIGHT - TILE_SIZE*2));

                zivStudents.push({
                    id: `ziv_${i}`, name: zivStudentNames[i], teacher: "Ziv",
                    x: studentX, y: studentY,
                    width: TILE_SIZE, height: TILE_SIZE,
                    color: ZIV_STUDENT_COLOR,
                    isWandering: isWanderingZ,
                    wanderTargetX: studentX, wanderTargetY: studentY, 
                    speed: studentSpeed,
                    wanderTimer: 0, wanderDelay: getRandomInt(120, 300), 
                    lastDirection: { x: 0, y: 0 },
                    seatX: currentSeatX, 
                    seatY: currentSeatY,
                });
            }
        }
        
        function initializeAllStudents() {
            initializeKremerStudents();
            initializeZivStudents();
        }


        function checkCollision(rect1, rect2) {
            if (!rect1 || !rect2) return false; 
            if (rect2.isBench) return false; 
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        function findPathAwayFromTeacher(student, teacher) {
            const dx = student.x - teacher.x; const dy = student.y - teacher.y;
            let targetX, targetY;

            if (student.personality.intelligence > 0.6) { 
                let bestHidingSpot = null; let maxScore = -Infinity;
                tables.forEach(table => {
                    if (table.id === "kremer_table" || table.isBench) return; 
                    const tableCenterX = table.x + table.width / 2; const tableCenterY = table.y + table.height / 2;
                    const teacherToTableX = tableCenterX - teacher.x; const teacherToTableY = tableCenterY - teacher.y;
                    const distTeacherToTable = Math.sqrt(teacherToTableX*teacherToTableX + teacherToTableY*teacherToTableY) || 1;
                    const hideX = tableCenterX + (teacherToTableX / distTeacherToTable) * (table.width/2 + TILE_SIZE);
                    const hideY = tableCenterY + (teacherToTableY / distTeacherToTable) * (table.height/2 + TILE_SIZE);
                    const distStudentToHide = distance(student, {x: hideX, y: hideY, width:1, height:1});
                    let score = (1000 / (distStudentToHide + 1)) + distTeacherToTable; 
                    if (isPathBlocked(student.x, student.y, hideX, hideY)) score -= 500; 
                    if (score > maxScore) { maxScore = score; bestHidingSpot = { x: hideX, y: hideY }; }
                });
                if (bestHidingSpot) { targetX = bestHidingSpot.x; targetY = bestHidingSpot.y; }
                else { 
                    const escapeDist = TILE_SIZE * (10 + 5 * student.personality.bravery);
                    const currentDist = Math.sqrt(dx * dx + dy * dy) || 1;
                    targetX = student.x + (dx / currentDist) * escapeDist; targetY = student.y + (dy / currentDist) * escapeDist;
                }
            } else { 
                const escapeDist = TILE_SIZE * (10 + 5 * student.personality.bravery); 
                const currentDist = Math.sqrt(dx * dx + dy * dy) || 1; 
                targetX = student.x + (dx / currentDist) * escapeDist; targetY = student.y + (dy / currentDist) * escapeDist;
            }
            targetX = Math.max(TILE_SIZE, Math.min(targetX, WORLD_WIDTH - TILE_SIZE * 2));
            targetY = Math.max(TILE_SIZE, Math.min(targetY, WORLD_HEIGHT - TILE_SIZE * 2));
            return { x: targetX, y: targetY };
        }

        function isPathBlocked(startX, startY, endX, endY) {
            const dist = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
            const steps = Math.max(1, Math.ceil(dist / (TILE_SIZE / 2))); 
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const checkX = startX + (endX - startX) * t; const checkY = startY + (endY - startY) * t;
                for (const table of tables) { 
                    if (table.isBench) continue; 
                    if (checkX >= table.x && checkX <= table.x + table.width && checkY >= table.y && checkY <= table.y + table.height) return true;
                }
            }
            return false;
        }

        function findPathAroundObstacles(student, targetX, targetY) {
            if (!isPathBlocked(student.x + student.width/2, student.y + student.height/2, targetX, targetY)) return { x: targetX, y: targetY };
            
            const possibleWaypoints = []; const checkAngles = 16; 
            for (let i = 0; i < checkAngles; i++) {
                const angle = (i / checkAngles) * Math.PI * 2;
                const dist = TILE_SIZE * (5 + student.personality.intelligence * 5); 
                const wpX = student.x + student.width/2 + Math.cos(angle) * dist; const wpY = student.y + student.height/2 + Math.sin(angle) * dist;
                
                if (wpX > 0 && wpX < WORLD_WIDTH && wpY > 0 && wpY < WORLD_HEIGHT && 
                    !isPathBlocked(student.x + student.width/2, student.y + student.height/2, wpX, wpY)) {
                    const distToTarget = Math.sqrt(Math.pow(wpX - targetX, 2) + Math.pow(wpY - targetY, 2));
                    const directDistToTarget = Math.sqrt(Math.pow(student.x - targetX, 2) + Math.pow(student.y - targetY, 2));
                    const score = distToTarget + Math.abs(directDistToTarget - distToTarget) * 0.5; 
                    possibleWaypoints.push({ x: wpX, y: wpY, score: score });
                }
            }
            if (possibleWaypoints.length > 0) { 
                possibleWaypoints.sort((a, b) => a.score - b.score); 
                return possibleWaypoints[0]; 
            }
            return { x: targetX, y: targetY }; 
        }

        function spawnPowerUps() {
            powerUps.length = 0; 
            const maxPowerUps = 5;
            const count = Math.min(maxPowerUps, Math.floor((students.length - player.captureCount) / 2.5) +1 ); 

            for (let i = 0; i < count; i++) {
                let x, y, validPosition; let attempts = 0;
                do {
                    validPosition = true; attempts++;
                    x = getRandomInt(TILE_SIZE * 2, WORLD_WIDTH - TILE_SIZE * 3); y = getRandomInt(TILE_SIZE * 2, WORLD_HEIGHT - TILE_SIZE * 3);
                    const tempPowerUp = {x, y, width: TILE_SIZE, height: TILE_SIZE};
                    for (const table of tables) {
                        if (table.isBench) continue; 
                        if (checkCollision(tempPowerUp, {x: table.x - TILE_SIZE, y: table.y - TILE_SIZE, width: table.width + TILE_SIZE*2, height: table.height + TILE_SIZE*2})) { 
                            validPosition = false; break; 
                        }
                    }
                    if (validPosition) for (const pUp of powerUps) if (distance(tempPowerUp, pUp) < TILE_SIZE * 8) { validPosition = false; break; } 
                    
                    const kremerTable = tables[KREMER_TABLE_INDEX];
                    const playerStartX = kremerTable.x + kremerTable.width / 2; const playerStartY = kremerTable.y + kremerTable.height + TILE_SIZE * 2;
                    if (distance(tempPowerUp, {x:playerStartX, y:playerStartY, width:1, height:1}) < TILE_SIZE * 10) validPosition = false;
                    
                    if (attempts > 100) break; 
                } while (!validPosition);

                if (validPosition) {
                    const type = powerUpTypes[getRandomInt(0, powerUpTypes.length - 1)];
                    powerUps.push({ x, y, width: TILE_SIZE, height: TILE_SIZE, type, pulseTimer: Math.random() * Math.PI * 2 });
                }
            }
        }

        function updatePowerUps() {
            if (gamePaused || gameStates.isTransitioningDay()) return;
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const powerUp = powerUps[i]; powerUp.pulseTimer += 0.05; 
                if (checkCollision(player, powerUp)) { 
                    powerUp.type.effect();
                    powerUps.splice(i, 1); 
                }
            }
            if (powerUps.length < 2 && Math.random() < 0.0025 && (students.length - player.captureCount > 0) ) spawnPowerUps();
        }

        function updateCamera() {
            const targetCamX = player.x - camera.width / (2 * camera.zoom) + player.width / 2;
            const targetCamY = player.y - camera.height / (2 * camera.zoom) + player.height / 2;
            camera.x += (targetCamX - camera.x) * 0.08; 
            camera.y += (targetCamY - camera.y) * 0.08;
            camera.x = Math.max(0, Math.min(camera.x, WORLD_WIDTH - camera.width / camera.zoom));
            camera.y = Math.max(0, Math.min(camera.y, WORLD_HEIGHT - camera.height / camera.zoom));
        }

        function updatePlayer() {
            if (gamePaused || gameStates.isTransitioningDay()) return;

            if (player.isSprinting && keys.shift && player.stamina > 0) { 
                player.currentSpeed = player.baseSpeed * player.sprintMultiplier;
                player.stamina = Math.max(0, player.stamina - player.staminaDepletionRate);
                if (player.stamina <= 0) {
                    player.isSprinting = false; 
                    keys.shift = false; 
                    if (mobileButtons.sprint.pressed) mobileButtons.sprint.pressed = false;
                }
            } else {
                player.currentSpeed = player.baseSpeed;
                if (player.stamina < player.maxStamina) player.stamina = Math.min(player.maxStamina, player.stamina + player.staminaRegenRate);
            }

            let moveDeltaX = 0; let moveDeltaY = 0;
            if (player.dx !== 0 || player.dy !== 0) { 
                moveDeltaX = player.dx * player.currentSpeed; 
                moveDeltaY = player.dy * player.currentSpeed;
            }
            
            player.targetX = player.x + moveDeltaX; 
            player.targetY = player.y + moveDeltaY;

            const smoothDx = player.targetX - player.x;
            const smoothDy = player.targetY - player.y;
            if (Math.abs(smoothDx) > 0.1 || Math.abs(smoothDy) > 0.1) { 
                player.x += smoothDx * player.movementSmoothing;
                player.y += smoothDy * player.movementSmoothing;
            } else { 
                player.x = player.targetX;
                player.y = player.targetY;
            }

            player.x = Math.max(0, Math.min(player.x, WORLD_WIDTH - player.width));
            player.y = Math.max(0, Math.min(player.y, WORLD_HEIGHT - player.height));

            for (const table of tables) { 
                if (table.isBench) continue; 
                if (checkCollision(player, table)) {
                    const overlapLeft = (player.x + player.width) - table.x;
                    const overlapRight = (table.x + table.width) - player.x;
                    const overlapTop = (player.y + player.height) - table.y;
                    const overlapBottom = (table.y + table.height) - player.y;
                    const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

                    if (minOverlap === overlapLeft) player.x = table.x - player.width;
                    else if (minOverlap === overlapRight) player.x = table.x + table.width;
                    else if (minOverlap === overlapTop) player.y = table.y - player.height;
                    else if (minOverlap === overlapBottom) player.y = table.y + table.height;
                    
                    player.targetX = player.x; 
                    player.targetY = player.y;
                }
            }
        }
        
        function getMoodEmoji(student) {
            if (student.madness > 70) return ""; 
            if (student.madness > 40) return ""; 
            if (student.happiness <= 20 && student.boredom > 50) return ""; 
            if (student.happiness <= 40) return ""; 
            if (student.happiness > 70) return ""; 
            if (student.happiness > 40) return ""; 
            return ""; 
        }


        function updateKremerStudents() {
            if (gamePaused || gameStates.isTransitioningDay()) return;
            students.forEach(student => { 
                if (student.frozenTimer && student.frozenTimer > 0) { student.frozenTimer--; return; } 

                if (student.isCaught && student.isAtSeat) {
                    student.boredom = Math.min(100, student.boredom + 0.1); 
                    student.happiness = Math.max(0, student.happiness - 0.02);
                    if (student.boredom >= 100) {
                        student.isCaught = false;
                        student.isAtSeat = false;
                        student.isWandering = true;
                        player.captureCount = Math.max(0, player.captureCount -1); 
                        student.boredom = 0;
                        student.happiness = Math.max(0, student.happiness - 30);
                        student.madness = Math.min(100, student.madness + 15);
                        const angle = Math.random() * Math.PI * 2;
                        student.wanderTargetX = student.seatX + Math.cos(angle) * TILE_SIZE * 10;
                        student.wanderTargetY = student.seatY + Math.sin(angle) * TILE_SIZE * 10;
                        showGameMessage(`${student.name} got bored and left!`);
                    }
                } else if (student.isCaught && !student.isAtSeat) { 
                    const targetX = student.seatX; const targetY = student.seatY;
                    const diffX = targetX - student.x; const diffY = targetY - student.y;
                    const distToSeat = Math.sqrt(diffX * diffX + diffY * diffY);

                    if (distToSeat < student.returnSpeed) { 
                        student.x = targetX; student.y = targetY; 
                        student.isAtSeat = true; 
                        student.boredom = 0; 
                    } else {
                        let moveX = (diffX / distToSeat) * student.returnSpeed; 
                        let moveY = (diffY / distToSeat) * student.returnSpeed;
                        let nextX = student.x + moveX; let nextY = student.y + moveY;
                        
                        for (const table of tables) { 
                            if (table.isBench) continue;
                            if (checkCollision({ ...student, x: nextX, y: nextY }, table)) {
                                if (Math.abs(diffX) > Math.abs(diffY)) { 
                                    if (!isPathBlocked(student.x, student.y, student.x, student.y + Math.sign(diffY) * student.returnSpeed)) { moveX = 0; moveY = Math.sign(diffY) * student.returnSpeed * 0.8; }
                                } else { 
                                    if (!isPathBlocked(student.x, student.y, student.x + Math.sign(diffX) * student.returnSpeed, student.y)) { moveX = Math.sign(diffX) * student.returnSpeed * 0.8; moveY = 0; }
                                }
                                break;
                            }
                        }
                        student.x += moveX; student.y += moveY;
                    }
                } else { 
                    student.isAtSeat = false; 
                    if (student.isWandering && !student.isAfraidOfTeacher) {
                        student.happiness = Math.min(100, student.happiness + 0.05);
                        student.madness = Math.max(0, student.madness - 0.03);
                    }

                    if (player.attractionField) {
                        const distToPlayer = distance(student, player);
                        if (distToPlayer < player.attractionRadius) {
                            const force = (1 - distToPlayer / player.attractionRadius) * player.attractionForce;
                            const dirX = player.x - student.x; const dirY = player.y - student.y;
                            const len = Math.sqrt(dirX * dirX + dirY * dirY) || 1;
                            student.x += (dirX / len) * force * student.speed * 0.5; 
                            student.y += (dirY / len) * force * student.speed * 0.5;
                        }
                    }

                    const distToTeacher = distance(student, player);
                    if (distToTeacher < DETECTION_RADIUS && !student.isAfraidOfTeacher) {
                        if (Math.random() > student.personality.bravery) { 
                            student.isAfraidOfTeacher = true; student.isWandering = false;
                            student.currentMessage = "!"; student.messageTimer = 60; 
                        }
                    } else if (distToTeacher >= DETECTION_RADIUS * 1.5 && student.isAfraidOfTeacher) { 
                        if (Math.random() < 0.05 / (student.personality.stubbornness + 0.1)) { 
                            student.isAfraidOfTeacher = false; student.isWandering = true; student.wanderTimer = student.wanderDelay; 
                        }
                    }
                    if (student.messageTimer > 0) student.messageTimer--; else student.currentMessage = "";

                    if (student.isAfraidOfTeacher) {
                        const escapeTarget = findPathAwayFromTeacher(student, player);
                        const finalPathTarget = findPathAroundObstacles(student, escapeTarget.x, escapeTarget.y);
                        const diffX = finalPathTarget.x - student.x; const diffY = finalPathTarget.y - student.y;
                        const distToTarget = Math.sqrt(diffX * diffX + diffY * diffY);

                        if (distToTarget > student.runSpeed) {
                            let moveX = (diffX / distToTarget) * student.runSpeed; let moveY = (diffY / distToTarget) * student.runSpeed;
                            moveX = moveX * 0.8 + student.lastDirection.x * 0.2; 
                            moveY = moveY * 0.8 + student.lastDirection.y * 0.2;
                            const moveLen = Math.sqrt(moveX*moveX + moveY*moveY) || 1;
                            if (moveLen > student.runSpeed) { moveX = (moveX/moveLen) * student.runSpeed; moveY = (moveY/moveLen) * student.runSpeed; }
                            student.lastDirection = { x: moveX, y: moveY };

                            let nextX = student.x + moveX; let nextY = student.y + moveY; let collided = false;
                            for (const table of tables) {
                                if (table.isBench) continue;
                                if (checkCollision({ ...student, x: nextX, y: nextY }, table)) { 
                                    collided = true; 
                                    student.x -= moveX * 0.5; student.y -= moveY * 0.5; 
                                    student.lastDirection = {x: -student.lastDirection.x *0.5 , y: -student.lastDirection.y*0.5}; 
                                    student.escapeFailCounter++; 
                                    if(student.escapeFailCounter > 5) { 
                                        student.isAfraidOfTeacher = false; student.isWandering = true; student.wanderTimer = 0; student.escapeFailCounter = 0; 
                                    }
                                    break; 
                                }
                            }
                            if (!collided) { student.x = nextX; student.y = nextY; student.escapeFailCounter = 0; }
                        } else { 
                            student.escapeTimer++; if(student.escapeTimer > 120) { 
                                student.isAfraidOfTeacher = false; student.isWandering = true; student.escapeTimer = 0;
                            }
                        }
                        student.x = Math.max(0, Math.min(student.x, WORLD_WIDTH - student.width)); 
                        student.y = Math.max(0, Math.min(student.y, WORLD_HEIGHT - student.height));
                    } else if (student.isWandering) {
                        student.wanderTimer++;
                        if (student.wanderTimer >= student.wanderDelay || distance(student, {x: student.wanderTargetX, y: student.wanderTargetY, width:1, height:1}) < student.speed * 2) { 
                            student.wanderTimer = 0; student.wanderDelay = getRandomInt(100, 300); 
                            const angle = Math.random() * Math.PI * 2; const wanderDist = TILE_SIZE * getRandomInt(5, 15);
                            student.wanderTargetX = student.x + Math.cos(angle) * wanderDist; 
                            student.wanderTargetY = student.y + Math.sin(angle) * wanderDist;
                            student.wanderTargetX = Math.max(TILE_SIZE, Math.min(student.wanderTargetX, WORLD_WIDTH - TILE_SIZE*2));
                            student.wanderTargetY = Math.max(TILE_SIZE, Math.min(student.wanderTargetY, WORLD_HEIGHT - TILE_SIZE*2));
                        }
                        const diffX = student.wanderTargetX - student.x; const diffY = student.wanderTargetY - student.y;
                        const distToTarget = Math.sqrt(diffX * diffX + diffY * diffY);

                        if (distToTarget > student.speed) {
                            let moveX = (diffX / distToTarget) * student.speed; let moveY = (diffY / distToTarget) * student.speed;
                            moveX = moveX * 0.7 + student.lastDirection.x * 0.3; 
                            moveY = moveY * 0.7 + student.lastDirection.y * 0.3;
                            const moveLen = Math.sqrt(moveX*moveX + moveY*moveY) || 1;
                            if (moveLen > student.speed) { moveX = (moveX/moveLen) * student.speed; moveY = (moveY/moveLen) * student.speed; }
                            student.lastDirection = { x: moveX, y: moveY };

                            let nextX = student.x + moveX; let nextY = student.y + moveY; let collision = false;
                            const futureStudent = { ...student, x: nextX, y: nextY };
                            for (const table of tables) {
                                if (table.isBench) continue;
                                if (checkCollision(futureStudent, table)) { collision = true; break; }
                            }
                            for (const otherStudent of students) if (student.id !== otherStudent.id && !otherStudent.isCaught && distance(futureStudent, otherStudent) < TILE_SIZE * 1.5) { collision = true; break; }
                            
                            if (!collision) { student.x = nextX; student.y = nextY; } 
                            else { student.wanderTimer = student.wanderDelay; student.lastDirection = {x:0, y:0}; } 
                        } else student.wanderTimer = student.wanderDelay; 

                        student.x = Math.max(0, Math.min(student.x, WORLD_WIDTH - student.width)); 
                        student.y = Math.max(0, Math.min(student.y, WORLD_HEIGHT - student.height));
                    }

                    if (distance(player, student) < CAPTURE_RADIUS && !student.isCaught) {
                        student.isCaught = true; 
                        student.isAtSeat = false; 
                        student.isWandering = false; 
                        student.isAfraidOfTeacher = false; 
                        student.currentMessage = "";   
                        student.messageTimer = 0;
                        player.captureCount++; 
                        
                        student.timesCaughtThisDay++;
                        student.madness = Math.min(100, student.madness + 15 * student.timesCaughtThisDay);
                        student.happiness = Math.max(0, student.happiness - 20);

                        showGameMessage(`${student.name} caught! (${player.captureCount}/${students.length})`);
                    }
                }
            });
        }

        function updateZivStudents() {
            if (gamePaused || gameStates.isTransitioningDay()) return;
            const zivTable = tables[ZIV_TABLE_INDEX];
            const wanderBounds = { // Define a slightly larger area around Ziv's table for wandering
                minX: zivTable.x - TILE_SIZE * 6,
                maxX: zivTable.x + zivTable.width + TILE_SIZE * 6,
                minY: zivTable.y - TILE_SIZE * 6,
                maxY: zivTable.y + zivTable.height + TILE_SIZE * 6,
            };

            zivStudents.forEach(student => {
                if (student.isWandering) { 
                    student.wanderTimer++;
                    if (student.wanderTimer >= student.wanderDelay || distance(student, {x: student.wanderTargetX, y: student.wanderTargetY, width:1, height:1}) < student.speed * 2) {
                        student.wanderTimer = 0; student.wanderDelay = getRandomInt(150, 400); 
                        const angle = Math.random() * Math.PI * 2;
                        const wanderDist = TILE_SIZE * getRandomInt(3, 8); 
                        student.wanderTargetX = student.x + Math.cos(angle) * wanderDist;
                        student.wanderTargetY = student.y + Math.sin(angle) * wanderDist;

                        student.wanderTargetX = Math.max(wanderBounds.minX, Math.min(student.wanderTargetX, wanderBounds.maxX));
                        student.wanderTargetY = Math.max(wanderBounds.minY, Math.min(student.wanderTargetY, wanderBounds.maxY));
                        
                        student.wanderTargetX = Math.max(TILE_SIZE, Math.min(student.wanderTargetX, WORLD_WIDTH - TILE_SIZE*2));
                        student.wanderTargetY = Math.max(TILE_SIZE, Math.min(student.wanderTargetY, WORLD_HEIGHT - TILE_SIZE*2));
                    }

                    const diffX = student.wanderTargetX - student.x;
                    const diffY = student.wanderTargetY - student.y;
                    const distToTarget = Math.sqrt(diffX * diffX + diffY * diffY);

                    if (distToTarget > student.speed) {
                        let moveX = (diffX / distToTarget) * student.speed;
                        let moveY = (diffY / distToTarget) * student.speed;
                        moveX = moveX * 0.7 + student.lastDirection.x * 0.3;
                        moveY = moveY * 0.7 + student.lastDirection.y * 0.3;
                        const moveLen = Math.sqrt(moveX*moveX + moveY*moveY) || 1;
                        if (moveLen > student.speed) { moveX = (moveX/moveLen) * student.speed; moveY = (moveY/moveLen) * student.speed; }
                        student.lastDirection = { x: moveX, y: moveY };

                        let nextX = student.x + moveX; let nextY = student.y + moveY; let collision = false;
                        const futureStudent = { ...student, x: nextX, y: nextY };
                        for (const table of tables) {
                            if (table.isBench) continue; 
                            if (table.id !== "ziv_table" && checkCollision(futureStudent, table)) { 
                                collision = true; break; 
                            }
                        }
                        for (const otherZivStudent of zivStudents) if (student.id !== otherZivStudent.id && distance(futureStudent, otherZivStudent) < TILE_SIZE * 1.5) { collision = true; break; }
                        
                        if (!collision) { student.x = nextX; student.y = nextY; } 
                        else { student.wanderTimer = student.wanderDelay; student.lastDirection = {x:0, y:0}; }
                    } else {
                        student.wanderTimer = student.wanderDelay; 
                    }
                    student.x = Math.max(0, Math.min(student.x, WORLD_WIDTH - student.width));
                    student.y = Math.max(0, Math.min(student.y, WORLD_HEIGHT - student.height));
                } else { 
                    if (student.seatX !== null && student.seatY !== null) {
                       student.x = student.seatX;
                       student.y = student.seatY;
                    }
                }
            });
        }


        function update() { 
            environment.updateEnvironment(); 
            if (!gamePaused && !gameStates.isTransitioningDay()) { 
                specialAbilities.update();
                updatePlayer(); 
                updateKremerStudents(); 
                updateZivStudents();
                updatePowerUps();
            }
            updateCamera(); 
            gameStates.update(); 
        }
        
        // --- Drawing Functions ---
        function drawRect(x, y, width, height, color, alpha = 1) {
            const oldAlpha = ctx.globalAlpha;
            ctx.globalAlpha = alpha;
            ctx.fillStyle = color; ctx.fillRect(x, y, width, height);
            ctx.globalAlpha = oldAlpha;
        }
        function drawText(text, x, y, color = '#fff', size = 10, align = 'center', alpha = 1) {
            const oldAlpha = ctx.globalAlpha;
            ctx.globalAlpha = alpha;
            ctx.fillStyle = color; ctx.font = `${size}px 'Press Start 2P'`; ctx.textAlign = align; ctx.fillText(text, x, y);
            ctx.globalAlpha = oldAlpha;
        }
        function drawCircle(x, y, radius, color, alpha = 1) {
            const oldAlpha = ctx.globalAlpha;
            ctx.globalAlpha = alpha;
            ctx.fillStyle = color; ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI * 2); ctx.fill();
            ctx.globalAlpha = oldAlpha;
        }

        function drawGrid() {
            let gridStrokeStyle = 'rgba(58, 58, 58, 0.5)';
            let gridLineWidth = 0.5;

            if (specialAbilities.timeWarpEffectActive) { // Grid effect for Time Warp
                // This is handled by the overlay now, but you could add grid changes here too
            }
            
            ctx.strokeStyle = gridStrokeStyle; 
            ctx.lineWidth = gridLineWidth; 
            const gridSize = TILE_SIZE * 5;
            const startX = Math.floor(camera.x / gridSize) * gridSize; 
            const endX = Math.ceil((camera.x + camera.width / camera.zoom) / gridSize) * gridSize;
            const startY = Math.floor(camera.y / gridSize) * gridSize; 
            const endY = Math.ceil((camera.y + camera.height / camera.zoom) / gridSize) * gridSize;

            for (let gx = startX; gx < endX; gx += gridSize) { ctx.beginPath(); ctx.moveTo(gx, startY); ctx.lineTo(gx, endY); ctx.stroke(); }
            for (let gy = startY; gy < endY; gy += gridSize) { ctx.beginPath(); ctx.moveTo(startX, gy); ctx.lineTo(endX, gy); ctx.stroke(); }
        }

        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); 
            ctx.save(); 
            ctx.scale(camera.zoom, camera.zoom); 
            ctx.translate(-camera.x, -camera.y); 

            const bgColor = environment.getBackgroundColor();
            ctx.fillStyle = bgColor; 
            ctx.fillRect(camera.x, camera.y, camera.width / camera.zoom, camera.height / camera.zoom); 
            
            const lightLevel = environment.getLightLevel();
            drawGrid(); 

            tables.forEach(table => {
                drawRect(table.x, table.y, table.width, table.height, table.color, lightLevel);
                
                if (table.name === "Dining Table" && !table.isBench) { 
                    const tabletopPadding = TILE_SIZE * 0.2;
                    drawRect(table.x + tabletopPadding, table.y + tabletopPadding, 
                             table.width - 2 * tabletopPadding, table.height - 2 * tabletopPadding, 'rgba(0,0,0,0.15)', lightLevel);
                } else if (table.id === "kremer_table" || table.id === "ziv_table") { 
                    drawText(table.name, table.x + table.width / 2, table.y + table.height / 2 - 5, '#eee', 8, 'center', lightLevel);
                }
            });

            drawRect(ziv.x, ziv.y, ziv.width, ziv.height, ziv.color, lightLevel);
            drawText(ziv.name, ziv.x + ziv.width / 2, ziv.y - 6, '#fff', 8, 'center', lightLevel);

            // Kremer Seats & Seated Students
            kremerSeatPositions.forEach((seat) => {
                const studentAtSeat = students.find(s => s.isCaught && s.isAtSeat && s.seatX === seat.x && s.seatY === seat.y);
                if (studentAtSeat) {
                    drawRect(seat.x, seat.y, TILE_SIZE, TILE_SIZE, studentAtSeat.color, lightLevel);
                    const moodEmoji = getMoodEmoji(studentAtSeat);
                    drawText(`${moodEmoji} ${studentAtSeat.name} (K)`, seat.x + TILE_SIZE / 2, seat.y - 9, '#fff', 9, 'center', lightLevel);
                } else {
                    drawRect(seat.x, seat.y, TILE_SIZE, TILE_SIZE, '#555', lightLevel); 
                }
            });
            
            // Ziv Seats (draw all visual seat squares first)
            zivSeatPositions.forEach(seat => {
                drawRect(seat.x, seat.y, TILE_SIZE, TILE_SIZE, '#4a4a4a', lightLevel); 
            });

            powerUps.forEach(powerUp => {
                const pulseScale = 0.8 + Math.sin(powerUp.pulseTimer) * 0.2; const size = TILE_SIZE * pulseScale;
                const pX = powerUp.x + TILE_SIZE/2; const pY = powerUp.y + TILE_SIZE/2;
                drawCircle(pX, pY, size/2 * 1.5, powerUp.type.color, lightLevel * (0.3 + Math.sin(powerUp.pulseTimer * 1.5) * 0.2));
                drawCircle(pX, pY, size/2, powerUp.type.color, lightLevel);
                drawText(powerUp.type.name.charAt(0), pX, pY + 4, '#fff', 12, 'center', lightLevel); 
            });

            // Wandering or returning Kremer Students
            students.forEach(s => {
                if (!s.isAtSeat) { 
                    drawRect(s.x, s.y, s.width, s.height, s.color, lightLevel);
                    const moodEmoji = getMoodEmoji(s);
                    drawText(`${moodEmoji} ${s.name} (K)`, s.x + s.width / 2, s.y - 9, '#fff', 9, 'center', lightLevel); 
                    const messageYOffset = s.y - 9 - 10; // Place message above name
                    if (s.currentMessage && s.messageTimer > 0) drawText(s.currentMessage, s.x + s.width / 2, messageYOffset, '#ffcc00', 10, 'center', lightLevel); 
                    else if (s.isAfraidOfTeacher) drawText("!", s.x + s.width / 2, messageYOffset, '#ff3333', 10, 'center', lightLevel); 

                    if (player.radarActive && !s.isCaught) {
                        const dist = distance(player, s); const maxRadarDist = TILE_SIZE * 40;
                        if (dist < maxRadarDist) {
                            const radarIntensity = Math.max(0.2, 1 - dist / maxRadarDist);
                            const pulseSize = (4 + Math.sin(Date.now() * 0.008 + s.id.hashCode()) * 2) * radarIntensity; 
                            drawCircle(s.x + s.width / 2, s.y + s.height / 2, pulseSize, `rgba(255, 100, 100, ${radarIntensity * 0.7})`, lightLevel);
                        }
                    }
                    if (s.frozenTimer && s.frozenTimer > 0) {
                        drawRect(s.x - 2, s.y - 2, s.width + 4, s.height + 4, `rgba(173, 216, 230, ${0.3 + (s.frozenTimer % 60) / 120})`, lightLevel);
                        for(let k=0; k<3; k++) drawRect(s.x + Math.random()*s.width - 2, s.y + Math.random()*s.height - 2, 4, 4, 'rgba(220, 250, 255, 0.6)', lightLevel);
                    }
                }
            });

            // All Ziv Students (drawn over their seats if applicable, or at wandering pos)
            zivStudents.forEach(s => {
                drawRect(s.x, s.y, s.width, s.height, s.color, lightLevel); 
                drawText(`${s.name} (Z)`, s.x + s.width / 2, s.y - 9, '#fff', 9, 'center', lightLevel);
            });


            drawRect(player.x, player.y, player.width, player.height, player.color, lightLevel);
            drawText(player.name, player.x + player.width / 2, player.y - 6, '#fff', 8, 'center', lightLevel);
            if (player.attractionField) {
                const oldGlobalAlpha = ctx.globalAlpha; 
                ctx.globalAlpha = lightLevel * oldGlobalAlpha; 
                const pulse = Math.sin(Date.now() * 0.006) * 0.1; 
                ctx.strokeStyle = `rgba(255, 0, 204, ${0.3 + pulse * 0.2})`; ctx.lineWidth = 2 + pulse;
                ctx.beginPath(); ctx.arc(player.x + player.width/2, player.y + player.height/2, player.attractionRadius * (0.9 + pulse * 0.05) , 0, Math.PI * 2); ctx.stroke();
                ctx.globalAlpha = oldGlobalAlpha;
            }

            // Time Warp visual effect overlay
            if (specialAbilities.timeWarpEffectActive) {
                const overlayAlpha = 0.05 + Math.sin(Date.now() * 0.005) * 0.03; // Subtle pulse
                ctx.fillStyle = `rgba(70, 70, 150, ${overlayAlpha * lightLevel})`; // Bluish tint, respects light level
                ctx.fillRect(camera.x, camera.y, camera.width / camera.zoom, camera.height / camera.zoom);
            }
            
            ctx.restore(); 
            
            drawUI(); 
        }

        function drawUI() {
            const barWidth = Math.min(150, canvas.width * 0.20); 
            const barHeight = Math.min(15, canvas.height * 0.025);
            const padding = Math.min(10, Math.min(canvas.width, canvas.height) * 0.015); 
            const fontSizeSmall = Math.max(8, Math.min(10, Math.min(canvas.width, canvas.height) / 60));
            const fontSizeMedium = Math.max(10, Math.min(12, Math.min(canvas.width, canvas.height) / 50));

            drawRect(padding, padding, barWidth, barHeight, 'rgba(0,0,0,0.5)');
            const staminaWidth = (player.stamina / player.maxStamina) * (barWidth - 4); 
            ctx.fillStyle = player.isSprinting ? '#ff9900' : '#22cc22';
            ctx.fillRect(padding + 2, padding + 2, staminaWidth > 0 ? staminaWidth : 0, barHeight - 4);

            const abilityBarY = padding + barHeight + padding / 2;
            drawRect(padding, abilityBarY, barWidth, barHeight, 'rgba(0,0,0,0.5)');
            const cooldownWidth = (1 - specialAbilities.cooldown / specialAbilities.maxCooldown) * (barWidth - 4);
            ctx.fillStyle = specialAbilities.cooldown === 0 ? '#22aaff' : '#aaaaaa';
            ctx.fillRect(padding + 2, abilityBarY + 2, cooldownWidth > 0 ? cooldownWidth : 0, barHeight - 4);
            
            drawText(specialAbilities.available[specialAbilities.selectedAbility].name, padding + barWidth + padding, abilityBarY + barHeight/2 + fontSizeSmall/2.5, '#fff', fontSizeSmall, 'left');

            const studentsTextY = abilityBarY + barHeight + padding;
            drawText(`Students: ${player.captureCount}/${students.length}`, padding, studentsTextY, '#fff', fontSizeMedium, 'left'); 

            const currentTotalGameHours = GAME_DAY_START_HOUR + (environment.timeOfDay * GAME_DAY_DURATION_HOURS);
            const displayHour = Math.floor(currentTotalGameHours);
            const displayMinute = Math.floor((currentTotalGameHours % 1) * 60);
            const gameTimeDisplayY = studentsTextY + fontSizeMedium + padding / 2;
            drawText(`Time: ${displayHour < 10 ? '0' : ''}${displayHour}:${displayMinute < 10 ? '0' : ''}${displayMinute}`, padding, gameTimeDisplayY, '#fff', fontSizeMedium, 'left');

            drawText(`Day: ${currentDay}`, canvas.width - padding, padding + fontSizeSmall, '#fff', fontSizeSmall, 'right');
            
            if (Date.now() % 2000 < 1000 && gameTime < 10 && gameStates.currentState === gameStates.GAME && !gameStates.isTransitioningDay()) { 
                const hintText = isTouchDevice ? 'Joystick:Move, Buttons:Actions' : 'WASD/Arrows:Move, SHIFT:Sprint, SPACE:Ability, Q:Cycle, P:Pause';
                drawText(hintText, canvas.width / 2, canvas.height - padding - 5, '#ccc', fontSizeSmall);
            }

            if (isTouchDevice) { 
                drawMobileControls();
            }
        }

        function draw() { 
            if (gameStates.currentState === gameStates.GAME || gameStates.isTransitioningDay()) {
                drawGame();
            } else if (gameStates.currentState === gameStates.PAUSED) {
                drawGame(); 
                gameStates.draw(); 
            }
            else { 
                gameStates.draw(); 
            }
            if (fadeOverlayAlpha > 0) {
                ctx.fillStyle = `rgba(0, 0, 0, ${fadeOverlayAlpha})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }


        function gameLoop() { 
            update(); 
            draw(); 
            requestAnimationFrame(gameLoop); 
        }

        // --- Input Handling ---
        const keys = { up: false, down: false, left: false, right: false, shift: false, space: false, q: false, p: false, enter: false, escape: false };

        function handleKeyDown(e) {
            const key = e.key.toLowerCase();
            if (gameStates.isTransitioningDay()) return; 

            if (gameStates.currentState !== gameStates.GAME) { 
                gameStates.handleKeyPress(e.key); 
                return; 
            }
            if (["arrowup", "arrowdown", "arrowleft", "arrowright", "w", "a", "s", "d", "shift", " ", "q", "p", "escape"].includes(key)) e.preventDefault();
            
            switch (key) {
                case 'arrowup': case 'w': keys.up = true; break;
                case 'arrowdown': case 's': keys.down = true; break;
                case 'arrowleft': case 'a': keys.left = true; break;
                case 'arrowright': case 'd': keys.right = true; break;
                case 'shift': keys.shift = true; player.isSprinting = true; break;
                case ' ': keys.space = true; specialAbilities.activateAbility(); break; 
                case 'q': keys.q = true; specialAbilities.cycleAbility(); break;
                case 'p': 
                    if (gameStates.currentState === gameStates.GAME && !gamePaused) { 
                        gamePaused = true; 
                        gameStates.currentState = gameStates.PAUSED;
                    } else if (gameStates.currentState === gameStates.PAUSED && gamePaused) { 
                        gameStates.pauseMenu.options[0].action(); 
                    }
                    break;
                case 'escape': 
                    if (gameStates.currentState === gameStates.GAME && !gamePaused) { 
                        gamePaused = true; gameStates.currentState = gameStates.PAUSED; 
                    } else if (gameStates.currentState === gameStates.PAUSED) { 
                        gameStates.pauseMenu.options[0].action(); 
                    }
                    break;
            }
            if (gameStates.currentState === gameStates.GAME && !isTouchDevice) updatePlayerVelocity(); 
        }
        function handleKeyUp(e) {
            const key = e.key.toLowerCase();
            if (gameStates.isTransitioningDay()) return; 
            if (gameStates.currentState !== gameStates.GAME) return; 
            switch (key) {
                case 'arrowup': case 'w': keys.up = false; break;
                case 'arrowdown': case 's': keys.down = false; break;
                case 'arrowleft': case 'a': keys.left = false; break;
                case 'arrowright': case 'd': keys.right = false; break;
                case 'shift': keys.shift = false; player.isSprinting = false; break;
                case ' ': keys.space = false; break; 
                case 'q': keys.q = false; break;
            }
            if (gameStates.currentState === gameStates.GAME && !isTouchDevice) updatePlayerVelocity();
        }
        function updatePlayerVelocity() { 
            if (isTouchDevice && joystick.active) return; 

            player.dx = 0; player.dy = 0;
            if (keys.up) player.dy = -1; if (keys.down) player.dy = 1;
            if (keys.left) player.dx = -1; if (keys.right) player.dx = 1;
            if (player.dx !== 0 && player.dy !== 0) { 
                const length = Math.sqrt(player.dx * player.dx + player.dy * player.dy); 
                player.dx /= length; player.dy /= length; 
            }
        }
        document.addEventListener('keydown', handleKeyDown); 
        document.addEventListener('keyup', handleKeyUp);

        // --- Mobile Touch Controls & Fullscreen ---
        const joystick = {
            x: 0, y: 0, radius: 0, stickX: 0, stickY: 0, stickRadius: 0,
            active: false, touchId: null, maxDisplacement: 0, visible: false
        };
        const mobileButtons = {
            sprint: { x: 0, y: 0, width: 0, height: 0, text: "RUN", pressed: false, visible: false, touchId: null },
            activate: { x: 0, y: 0, width: 0, height: 0, text: "USE", pressed: false, visible: false },
            cycle: { x: 0, y: 0, width: 0, height: 0, text: "SWAP", pressed: false, visible: false }
        };

        function setupMobileControls() {
            if (!isTouchDevice) return;
            joystick.visible = true;
            mobileButtons.sprint.visible = true;
            mobileButtons.activate.visible = true;
            mobileButtons.cycle.visible = true;

            joystick.radius = Math.min(canvas.width, canvas.height) * 0.11; 
            joystick.x = joystick.radius * 1.3 + screenEdgePadding;
            joystick.y = canvas.height - joystick.radius * 1.3 - screenEdgePadding;
            joystick.stickRadius = joystick.radius * 0.45;
            joystick.stickX = joystick.x;
            joystick.stickY = joystick.y;
            joystick.maxDisplacement = joystick.radius - joystick.stickRadius;

            const buttonHeight = Math.min(canvas.width, canvas.height) * 0.07;
            const buttonWidth = buttonHeight * 1.7;
            const buttonMargin = buttonHeight * 0.25;

            mobileButtons.sprint.width = buttonWidth;
            mobileButtons.sprint.height = buttonHeight;
            mobileButtons.sprint.x = canvas.width - buttonWidth - buttonMargin - screenEdgePadding;
            mobileButtons.sprint.y = canvas.height - buttonHeight - buttonMargin - screenEdgePadding;
            
            mobileButtons.activate.width = buttonWidth;
            mobileButtons.activate.height = buttonHeight;
            mobileButtons.activate.x = canvas.width - buttonWidth - buttonMargin - screenEdgePadding;
            mobileButtons.activate.y = mobileButtons.sprint.y - buttonHeight - buttonMargin;

            mobileButtons.cycle.width = buttonWidth;
            mobileButtons.cycle.height = buttonHeight;
            mobileButtons.cycle.x = canvas.width - buttonWidth - buttonMargin - screenEdgePadding;
            mobileButtons.cycle.y = mobileButtons.activate.y - buttonHeight - buttonMargin;
        }

        function drawMobileControls() {
            if (!isTouchDevice || !joystick.visible || gameStates.isTransitioningDay()) return;

            drawCircle(joystick.x, joystick.y, joystick.radius, 'rgba(80, 80, 80, 0.4)');
            drawCircle(joystick.stickX, joystick.stickY, joystick.stickRadius, joystick.active ? 'rgba(180, 180, 180, 0.8)' : 'rgba(120, 120, 120, 0.6)');

            Object.values(mobileButtons).forEach(button => {
                if (button.visible) {
                    drawRect(button.x, button.y, button.width, button.height, button.pressed ? 'rgba(100, 100, 100, 0.8)' : 'rgba(60, 60, 60, 0.6)');
                    drawText(button.text, button.x + button.width / 2, button.y + button.height / 2 + button.height*0.1, '#fff', Math.min(12, button.height * 0.3), 'center');
                }
            });
        }
        
        function isTouchInCircle(touchX, touchY, circleX, circleY, circleRadius) {
            const dx = touchX - circleX;
            const dy = touchY - circleY;
            return (dx * dx + dy * dy) < (circleRadius * circleRadius);
        }

        function isTouchInRect(touchX, touchY, rect) {
            return touchX >= rect.x && touchX <= rect.x + rect.width &&
                   touchY >= rect.y && touchY <= rect.y + rect.height;
        }
        
        function requestNativeFullScreen() {
            if (canvas.requestFullscreen) {
                canvas.requestFullscreen();
            } else if (canvas.webkitRequestFullscreen) { 
                canvas.webkitRequestFullscreen();
            } else if (canvas.msRequestFullscreen) { 
                canvas.msRequestFullscreen();
            }
        }

        function exitNativeFullScreen() {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) { 
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) { 
                document.msExitFullscreen();
            }
        }

        function toggleFullScreen() {
            if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) {
                requestNativeFullScreen();
            } else {
                exitNativeFullScreen();
            }
        }

        function onFullScreenChange() {
            isFullscreenActive = !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement);
            screenEdgePadding = (isTouchDevice && !isFullscreenActive) ? Math.min(20, Math.min(window.innerWidth, window.innerHeight) * 0.03) : 0;
            resizeCanvasScoped(); // Use the scoped function name
        }

        document.addEventListener('fullscreenchange', onFullScreenChange);
        document.addEventListener('webkitfullscreenchange', onFullScreenChange); 
        document.addEventListener('msfullscreenchange', onFullScreenChange);    

        canvas.addEventListener('touchstart', function(e) {
            if (!isTouchDevice) return;
            e.preventDefault(); 
            const rect = canvas.getBoundingClientRect();

            if (gameStates.isTransitioningDay()) return;

            if (gameStates.currentState !== gameStates.GAME) {
                const touch = e.changedTouches[0]; 
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;

                if (gameStates.currentState === gameStates.MENU && gameStates.startScreen.fullscreenButtonRect && 
                    isTouchInRect(touchX, touchY, gameStates.startScreen.fullscreenButtonRect)) {
                    toggleFullScreen();
                    return;
                }

                if (gameStates.currentState === gameStates.MENU || gameStates.currentState === gameStates.PAUSED) {
                    let menuSystem = (gameStates.currentState === gameStates.MENU) ? gameStates.startScreen : gameStates.pauseMenu;
                    const optionHeight = Math.min(50, canvas.height / 10); 
                    const firstOptionYBase = (gameStates.currentState === gameStates.MENU) ? canvas.height / 2 + Math.min(30, canvas.height / 15) : canvas.height / 2;
                    for(let i=0; i < menuSystem.options.length; i++) {
                        const optionCenterY = firstOptionYBase + i * optionHeight;
                        const optionTopY = optionCenterY - optionHeight / 2;
                        const optionBottomY = optionCenterY + optionHeight / 2;
                        if (touchY > optionTopY && touchY < optionBottomY) {
                            menuSystem.selectedOption = i;
                            menuSystem.handleInput('enter'); 
                            return;
                        }
                    }
                } else if (gameStates.currentState === gameStates.INSTRUCTIONS || gameStates.currentState === gameStates.GAME_OVER || gameStates.currentState === gameStates.VICTORY) {
                    gameStates.handleKeyPress('enter');
                }
                return;
            }
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;

                if (!joystick.active && joystick.visible && isTouchInCircle(touchX, touchY, joystick.x, joystick.y, joystick.radius * 1.3)) { 
                    joystick.active = true;
                    joystick.touchId = touch.identifier;
                    const dxJoy = touchX - joystick.x;
                    const dyJoy = touchY - joystick.y;
                    const dist = Math.sqrt(dxJoy * dxJoy + dyJoy * dyJoy);
                    if (dist > joystick.maxDisplacement) {
                        joystick.stickX = joystick.x + (dxJoy / dist) * joystick.maxDisplacement;
                        joystick.stickY = joystick.y + (dyJoy / dist) * joystick.maxDisplacement;
                    } else {
                        joystick.stickX = touchX;
                        joystick.stickY = touchY;
                    }
                    player.dx = (joystick.stickX - joystick.x) / joystick.maxDisplacement;
                    player.dy = (joystick.stickY - joystick.y) / joystick.maxDisplacement;
                    continue; 
                }
                if (mobileButtons.sprint.visible && isTouchInRect(touchX, touchY, mobileButtons.sprint)) {
                    keys.shift = true; player.isSprinting = true;
                    mobileButtons.sprint.pressed = true;
                    mobileButtons.sprint.touchId = touch.identifier;
                    continue;
                }
                if (mobileButtons.activate.visible && isTouchInRect(touchX, touchY, mobileButtons.activate)) {
                    specialAbilities.activateAbility();
                    mobileButtons.activate.pressed = true;
                    setTimeout(() => { mobileButtons.activate.pressed = false; }, 150);
                    continue;
                }
                if (mobileButtons.cycle.visible && isTouchInRect(touchX, touchY, mobileButtons.cycle)) {
                    specialAbilities.cycleAbility();
                    mobileButtons.cycle.pressed = true;
                    setTimeout(() => { mobileButtons.cycle.pressed = false; }, 150);
                    continue;
                }
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', function(e) {
            if (!isTouchDevice || gameStates.currentState !== gameStates.GAME || gamePaused || gameStates.isTransitioningDay()) return; 
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();

            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                if (joystick.active && touch.identifier === joystick.touchId) {
                    const touchX = touch.clientX - rect.left;
                    const touchY = touch.clientY - rect.top;
                    let dxJoy = touchX - joystick.x;
                    let dyJoy = touchY - joystick.y;
                    const dist = Math.sqrt(dxJoy * dxJoy + dyJoy * dyJoy);

                    if (dist === 0) { 
                        player.dx = 0;
                        player.dy = 0;
                        joystick.stickX = joystick.x;
                        joystick.stickY = joystick.y;
                        return;
                    }

                    if (dist > joystick.maxDisplacement) {
                        dxJoy = (dxJoy / dist) * joystick.maxDisplacement;
                        dyJoy = (dyJoy / dist) * joystick.maxDisplacement;
                    }
                    joystick.stickX = joystick.x + dxJoy;
                    joystick.stickY = joystick.y + dyJoy;
                    player.dx = dxJoy / joystick.maxDisplacement;
                    player.dy = dyJoy / joystick.maxDisplacement;
                    
                    if (player.dx !== 0 || player.dy !== 0) { 
                        const length = Math.sqrt(player.dx * player.dx + player.dy * player.dy);
                        if (length > 1) { 
                            player.dx /= length; player.dy /= length;
                        }
                    }
                }
            }
        }, { passive: false });

        canvas.addEventListener('touchend', function(e) {
            if (!isTouchDevice || gameStates.currentState !== gameStates.GAME || gameStates.isTransitioningDay()) return;
             for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                if (joystick.active && touch.identifier === joystick.touchId) {
                    joystick.active = false;
                    joystick.touchId = null;
                    joystick.stickX = joystick.x;
                    joystick.stickY = joystick.y;
                    player.dx = 0;
                    player.dy = 0;
                }
                if (mobileButtons.sprint.touchId === touch.identifier) {
                    keys.shift = false; player.isSprinting = false;
                    mobileButtons.sprint.pressed = false;
                    mobileButtons.sprint.touchId = null;
                }
            }
        });

        String.prototype.hashCode = function() {
            var hash = 0, i, chr;
            if (this.length === 0) return hash;
            for (i = 0; i < this.length; i++) {
                chr   = this.charCodeAt(i);
                hash  = ((hash << 5) - hash) + chr;
                hash |= 0; 
            }
            return Math.abs(hash); 
        };

        let resizeCanvasScoped; // Declare here to be accessible by onFullScreenChange

        // --- Game Initialization ---
        function initGame() {
            resizeCanvasScoped = () => { 
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                camera.width = canvas.width;
                camera.height = canvas.height;
                screenEdgePadding = (isTouchDevice && !isFullscreenActive) ? Math.min(20, Math.min(window.innerWidth, window.innerHeight) * 0.03) : 0;
                if (isTouchDevice) setupMobileControls(); 
                if(gameStates.currentState !== gameStates.GAME || gameStates.isTransitioningDay()) {
                    if (typeof gameStates.draw === 'function') gameStates.draw();
                } else if (typeof draw === 'function') { // Ensure draw is callable if in game state
                    draw();
                }
            };
            window.addEventListener('resize', resizeCanvasScoped); 
            resizeCanvasScoped(); 

            if (tables.length > KREMER_TABLE_INDEX && tables[KREMER_TABLE_INDEX]) {
                 player.x = tables[KREMER_TABLE_INDEX].x + tables[KREMER_TABLE_INDEX].width / 2;
                 player.y = tables[KREMER_TABLE_INDEX].y + tables[KREMER_TABLE_INDEX].height + TILE_SIZE * 2;
            } else { 
                player.x = WORLD_WIDTH / 2;
                player.y = WORLD_HEIGHT / 2;
            }
            player.targetX = player.x; player.targetY = player.y; 

            updateCamera(); 
            gameStates.currentState = gameStates.MENU; 
            gameLoop(); 
        }
        window.addEventListener('load', initGame);
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Catch the Missing Students</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            background-color: #1a1a1a; /* Fallback background */
            font-family: 'Press Start 2P', cursive;
            color: #fff;
            overflow: hidden; /* Prevent scrollbars */
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #gameCanvas {
            border: none; /* Removed border for full screen feel */
            background-color: #2c2c2c; /* Initial canvas background */
            display: block;
            /* box-shadow: 0 0 20px rgba(255, 255, 255, 0.3); Removed for cleaner mobile */
            max-width: 100%; /* Ensure canvas doesn't overflow */
            max-height: 100%; /* Ensure canvas doesn't overflow */
            object-fit: contain; /* Or 'cover' depending on desired behavior if aspect ratio is forced */
        }
        #gameUI {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 8px;
            background-color: rgba(0,0,0,0.7); /* Slightly more opaque */
            border-radius: 5px;
            font-size: clamp(0.6em, 2vw, 0.8em); /* Responsive font size */
            color: #ffcc00;
            z-index: 10;
            pointer-events: none;
            max-width: 80%; /* Prevent message box from being too wide */
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="gameUI" class="hidden">Press WASD or Arrow Keys to move</div>
    <script>
        // --- Canvas and Context ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameUI = document.getElementById('gameUI');

        // --- Game Settings ---
        const TILE_SIZE = 20; // Base size for objects
        const WORLD_WIDTH = TILE_SIZE * 100;
        const WORLD_HEIGHT = TILE_SIZE * 80;
        const DETECTION_RADIUS = TILE_SIZE * 8;
        const ESCAPE_RADIUS = TILE_SIZE * 5;
        const CAPTURE_RADIUS = TILE_SIZE * 0.8;
        let gameTime = 0;
        let gamePaused = false;

        // --- Camera ---
        const camera = {
            x: 0, y: 0,
            width: canvas.width,
            height: canvas.height,
            zoom: 1 // Zoom level can be adjusted for better visibility on small screens if needed
        };

        // --- Characters and Objects ---
        const player = {
            name: "Kremer",
            x: WORLD_WIDTH / 2, y: WORLD_HEIGHT / 2,
            width: TILE_SIZE, height: TILE_SIZE,
            color: '#007bff', // Blue
            baseSpeed: 30, 
            currentSpeed: 30,
            targetX: WORLD_WIDTH / 2, targetY: WORLD_HEIGHT / 2,
            dx: 0, dy: 0,
            movementSmoothing: 0.2,
            stamina: 100, maxStamina: 100,
            staminaRegenRate: 0.5, staminaDepletionRate: 0.8,
            isSprinting: false, sprintMultiplier: 1.6,
            captureCount: 0,
            radarActive: false,
            attractionField: false, attractionRadius: 0, attractionForce: 0
        };

        const ziv = {
            name: "Ziv",
            x: TILE_SIZE * 80, y: TILE_SIZE * 10,
            width: TILE_SIZE, height: TILE_SIZE,
            color: '#6f42c1' // Purple
        };

        const tables = [
            {
                name: "Class Table",
                x: TILE_SIZE * 5, y: WORLD_HEIGHT - TILE_SIZE * 15,
                width: TILE_SIZE * 10, height: TILE_SIZE * 4,
                color: '#6c757d' // Gray
            },
            {
                name: "Ziv's Table",
                x: ziv.x - TILE_SIZE * 4, y: ziv.y + TILE_SIZE * 2,
                width: TILE_SIZE * 8, height: TILE_SIZE * 3,
                color: '#5c656d' // Darker Gray
            }
        ];

        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        
        const tableColors = ['#8B4513', '#A0522D', '#803515', '#975429']; // Brownish colors for tables

        for (let i = 0; i < 15; i++) {
            const width = getRandomInt(3, 8) * TILE_SIZE;
            const height = getRandomInt(2, 5) * TILE_SIZE;
            let x, y, validPosition;
            do {
                validPosition = true;
                x = getRandomInt(TILE_SIZE * 5, WORLD_WIDTH - width - TILE_SIZE * 5);
                y = getRandomInt(TILE_SIZE * 5, WORLD_HEIGHT - height - TILE_SIZE * 5);
                for (const table of tables) {
                    const distanceVal = Math.sqrt(
                        Math.pow((x + width/2) - (table.x + table.width/2), 2) +
                        Math.pow((y + height/2) - (table.y + table.height/2), 2)
                    );
                    if (distanceVal < TILE_SIZE * 15) { // Ensure tables are not too close
                        validPosition = false;
                        break;
                    }
                }
            } while (!validPosition);
            tables.push({
                name: "Dining Table", 
                x, y, width, height,
                color: tableColors[getRandomInt(0, tableColors.length -1)] 
            });
        }

        const KREMER_TABLE_INDEX = 0;
        const studentNames = [
            "Adi", "Bar", "Chen", "Dana", "Eli", "Gali", "Hila", "Itai",
            "Keren", "Lior", "Maya", "Noa", "Omer", "Rotem", "Shira"
        ];
        const students = [];
        const UNIFORM_STUDENT_COLOR = '#28a745'; // Uniform green for students

        const powerUps = [];
        const powerUpTypes = [
            {
                name: "Speed Boost", color: "#ffcc00", duration: 10,
                effect: () => {
                    player.baseSpeed = 6; 
                    setTimeout(() => {
                        player.baseSpeed = 4.5; 
                        gameUI.classList.remove('hidden');
                        gameUI.textContent = "Speed boost ended!";
                        setTimeout(() => gameUI.classList.add('hidden'), 2000);
                    }, 10000);
                }
            },
            {
                name: "Student Freeze", color: "#00ccff", duration: 5,
                effect: () => {
                    students.forEach(s => { if (!s.isCaught) s.frozenTimer = 5 * 60; }); // 5 seconds at 60fps
                    gameUI.classList.remove('hidden');
                    gameUI.textContent = "Student Freeze active!";
                    setTimeout(() => gameUI.classList.add('hidden'), 2000);
                }
            },
            {
                name: "Attraction Field", color: "#ff00cc", duration: 7,
                effect: () => {
                    player.attractionField = true;
                    player.attractionRadius = TILE_SIZE * 10;
                    player.attractionForce = 0.5;
                    gameUI.classList.remove('hidden');
                    gameUI.textContent = "Attraction Field active!";
                    setTimeout(() => {
                        player.attractionField = false;
                        gameUI.textContent = "Attraction field deactivated!";
                        setTimeout(() => gameUI.classList.add('hidden'), 2000);
                    }, 7000);
                }
            },
            {
                name: "Stamina Refill", color: "#00ff00", duration: 0,
                effect: () => {
                    player.stamina = player.maxStamina;
                    gameUI.classList.remove('hidden');
                    gameUI.textContent = "Stamina Refilled!";
                    setTimeout(() => gameUI.classList.add('hidden'), 2000);
                }
            }
        ];

        const environment = {
            timeOfDay: 0, // 0 = dawn, 0.5 = noon, 1 = dusk
            dayLength: 120, // seconds for a full day
            updateEnvironment: function() {
                if (gamePaused) return;
                this.timeOfDay = (this.timeOfDay + 1/(this.dayLength * 60)) % 1;
            },
            getBackgroundColor: function() {
                let skyColor;
                if (this.timeOfDay < 0.25) { // Dawn
                    const t = this.timeOfDay / 0.25;
                    skyColor = `rgb(${Math.floor(50 + t * 100)}, ${Math.floor(50 + t * 150)}, ${Math.floor(100 + t * 155)})`;
                } else if (this.timeOfDay < 0.75) { // Day
                    skyColor = '#87CEEB'; // Sky blue
                } else { // Dusk
                    const t = (this.timeOfDay - 0.75) / 0.25;
                    skyColor = `rgb(${Math.floor(150 - t * 100)}, ${Math.floor(200 - t * 150)}, ${Math.floor(255 - t * 155)})`;
                }
                return skyColor;
            },
            getLightLevel: function() {
                if (this.timeOfDay < 0.25) return 0.7 + this.timeOfDay * 1.2; // Dawn: 0.7 to 1.0
                else if (this.timeOfDay < 0.75) return 1.0; // Day: 1.0
                else return 1.0 - (this.timeOfDay - 0.75) * 0.8; // Dusk: 1.0 to 0.8
            }
        };

        const specialAbilities = {
            active: false, cooldown: 0, maxCooldown: 600, // 10 seconds cooldown (600 frames / 60fps)
            available: [
                {
                    name: "Time Warp", description: "Slow down time for everyone except you.",
                    activate: function() {
                        const slowFactor = 0.3;
                        const originalSpeeds = [];
                        students.forEach((s, i) => {
                            originalSpeeds[i] = { speed: s.speed, runSpeed: s.runSpeed, returnSpeed: s.returnSpeed };
                            s.speed *= slowFactor; s.runSpeed *= slowFactor; s.returnSpeed *= slowFactor;
                        });
                        gameUI.classList.remove('hidden'); gameUI.textContent = "Time Warp active!";
                        ctx.filter = "sepia(0.5) hue-rotate(240deg)"; // Visual effect for time warp
                        setTimeout(() => { 
                            students.forEach((s, i) => {
                                if (originalSpeeds[i]) { // Check if originalSpeeds[i] exists
                                    s.speed = originalSpeeds[i].speed;
                                    s.runSpeed = originalSpeeds[i].runSpeed;
                                    s.returnSpeed = originalSpeeds[i].returnSpeed;
                                }
                            });
                            ctx.filter = "none"; // Reset visual effect
                            gameUI.textContent = "Time Warp ended";
                            setTimeout(() => gameUI.classList.add('hidden'), 2000);
                            specialAbilities.active = false;
                            specialAbilities.cooldown = specialAbilities.maxCooldown;
                        }, 2500); // Duration changed to 2.5 seconds
                    }
                },
                {
                    name: "Super Sprint", description: "Infinite stamina and doubled speed for a short time.",
                    activate: function() {
                        const originalSpeed = player.baseSpeed;
                        player.baseSpeed *= 2; player.stamina = player.maxStamina; // Refill stamina
                        gameUI.classList.remove('hidden'); gameUI.textContent = "Super Sprint active!";
                        setTimeout(() => {
                            player.baseSpeed = originalSpeed;
                            gameUI.textContent = "Super Sprint ended";
                            setTimeout(() => gameUI.classList.add('hidden'), 2000);
                            specialAbilities.active = false;
                            specialAbilities.cooldown = specialAbilities.maxCooldown;
                        }, 7000); // 7 seconds duration
                    }
                },
                {
                    name: "Student Radar", description: "Reveal the positions of all students.",
                    activate: function() {
                        player.radarActive = true;
                        gameUI.classList.remove('hidden'); gameUI.textContent = "Student Radar active!";
                        setTimeout(() => {
                            player.radarActive = false;
                            gameUI.textContent = "Student Radar ended";
                            setTimeout(() => gameUI.classList.add('hidden'), 2000);
                            specialAbilities.active = false;
                            specialAbilities.cooldown = specialAbilities.maxCooldown;
                        }, 12000); // 12 seconds duration
                    }
                }
            ],
            selectedAbility: 0,
            update: function() {
                if (gamePaused) return;
                if (this.cooldown > 0) this.cooldown--;
            },
            activateAbility: function() {
                if (gamePaused) return;
                if (this.cooldown === 0 && !this.active) {
                    this.active = true; this.available[this.selectedAbility].activate();
                } else if (this.cooldown > 0) {
                    gameUI.classList.remove('hidden');
                    gameUI.textContent = `Ability on cooldown: ${Math.ceil(this.cooldown / 60)}s`;
                    setTimeout(() => gameUI.classList.add('hidden'), 2000);
                } else if (this.active){
                    gameUI.classList.remove('hidden');
                    gameUI.textContent = `Ability already active!`;
                    setTimeout(() => gameUI.classList.add('hidden'), 2000);
                }
            },
            cycleAbility: function() {
                if (gamePaused || this.active) return; // Prevent cycling while an ability is active or paused
                this.selectedAbility = (this.selectedAbility + 1) % this.available.length;
                gameUI.classList.remove('hidden');
                gameUI.textContent = `Selected: ${this.available[this.selectedAbility].name}`;
                setTimeout(() => gameUI.classList.add('hidden'), 2000);
            }
        };
        
        const gameStates = {
            MENU: 'menu', GAME: 'game', PAUSED: 'paused',
            GAME_OVER: 'gameOver', VICTORY: 'victory', INSTRUCTIONS: 'instructions',
            currentState: 'menu',
            startScreen: {
                title: "Catch The Students!",
                subtitle: "Can you bring them all back to class?",
                options: [
                    { text: "Start Game", action: () => gameStates.startGame() },
                    { text: "How to Play", action: () => gameStates.showInstructionsScreen() }
                ],
                selectedOption: 0,
                draw: function() {
                    ctx.fillStyle = '#2c2c2c'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#fff'; 
                    ctx.font = `${Math.min(32, canvas.width / 20)}px "Press Start 2P"`; // Responsive font
                    ctx.textAlign = 'center';
                    ctx.fillText(this.title, canvas.width / 2, canvas.height / 3);
                    ctx.font = `${Math.min(16, canvas.width / 35)}px "Press Start 2P"`;
                    ctx.fillText(this.subtitle, canvas.width / 2, canvas.height / 3 + Math.min(40, canvas.height / 10));
                    ctx.font = `${Math.min(20, canvas.width / 28)}px "Press Start 2P"`;
                    this.options.forEach((option, i) => {
                        ctx.fillStyle = (i === this.selectedOption) ? '#ffcc00' : '#fff';
                        ctx.fillText((i === this.selectedOption ? '> ' : '') + option.text + (i === this.selectedOption ? ' <' : ''), canvas.width / 2, canvas.height / 2 + i * Math.min(50, canvas.height / 10) + Math.min(30, canvas.height / 15));
                    });
                    ctx.font = `${Math.min(12, canvas.width / 45)}px "Press Start 2P"`; ctx.fillStyle = '#aaa';
                    ctx.fillText('Arrow Keys / WASD / Touch to Navigate, Enter / Tap to Select', canvas.width / 2, canvas.height - Math.min(50, canvas.height / 8));
                },
                handleInput: function(key) {
                    switch(key.toLowerCase()) {
                        case 'arrowup': case 'w': this.selectedOption = Math.max(0, this.selectedOption - 1); break;
                        case 'arrowdown': case 's': this.selectedOption = Math.min(this.options.length - 1, this.selectedOption + 1); break;
                        case 'enter': case ' ': this.options[this.selectedOption].action(); break;
                    }
                }
            },
            instructionsScreen: {
                draw: function() {
                    ctx.fillStyle = '#2c2c2c'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#fff'; 
                    ctx.font = `${Math.min(24, canvas.width / 22)}px "Press Start 2P"`; 
                    ctx.textAlign = 'center';
                    ctx.fillText("How to Play", canvas.width / 2, Math.min(80, canvas.height/8));
                    ctx.font = `${Math.min(12, canvas.width / 48, canvas.height / 30)}px "Press Start 2P"`; // Responsive font for instructions
                    ctx.textAlign = 'left';
                    const instructionsText = [
                        "- Use WASD or Arrow Keys to move", "- Hold SHIFT to sprint (uses stamina)",
                        "- Press SPACE to use your special ability", "- Press Q to cycle between abilities",
                        "- Collect power-ups to gain advantages", "- Students will run away when they see you!",
                        "- Different students have different personalities", "- Catch all 15 students to win",
                        "- Press P to pause the game", "- Touch Controls (Mobile):",
                        "  - Drag to move", "  - Tap bottom-right to sprint",
                        "  - Tap bottom-left to cycle ability", "  - Double-tap center to activate ability"
                    ];
                    const lineHeight = Math.min(25, canvas.height / 20);
                    const startY = Math.min(140, canvas.height / 5);
                    instructionsText.forEach((text, i) => ctx.fillText(text, canvas.width / 20, startY + i * lineHeight));
                    ctx.fillStyle = '#ffcc00'; ctx.textAlign = 'center'; 
                    ctx.font = `${Math.min(16, canvas.width / 35)}px "Press Start 2P"`;
                    ctx.fillText("Press ESC or Tap to return to menu", canvas.width / 2, canvas.height - Math.min(50, canvas.height / 10));
                },
                handleInput: function(key) {
                    if (key.toLowerCase() === 'escape' || key.toLowerCase() === 'enter' || key.toLowerCase() === ' ') { // Allow tap/enter to exit
                         gameStates.currentState = gameStates.MENU;
                    }
                }
            },
            pauseMenu: {
                 options: [
                    { text: "Resume", action: () => { gameStates.currentState = gameStates.GAME; gamePaused = false; } },
                    { text: "Restart", action: () => gameStates.restartGame() },
                    { text: "Main Menu", action: () => { gameStates.currentState = gameStates.MENU; gamePaused = false; gameTime = 0;} }
                ],
                selectedOption: 0,
                draw: function() {
                    drawGame(); // Draw paused game underneath
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#fff'; 
                    ctx.font = `${Math.min(32, canvas.width / 20)}px "Press Start 2P"`; 
                    ctx.textAlign = 'center';
                    ctx.fillText("PAUSED", canvas.width / 2, canvas.height / 3);
                    ctx.font = `${Math.min(20, canvas.width / 28)}px "Press Start 2P"`;
                    this.options.forEach((option, i) => {
                        ctx.fillStyle = (i === this.selectedOption) ? '#ffcc00' : '#fff';
                        ctx.fillText((i === this.selectedOption ? '> ' : '') + option.text + (i === this.selectedOption ? ' <' : ''), canvas.width / 2, canvas.height / 2 + i * Math.min(50, canvas.height / 10));
                    });
                },
                handleInput: function(key) {
                    switch(key.toLowerCase()) {
                        case 'arrowup': case 'w': this.selectedOption = Math.max(0, this.selectedOption - 1); break;
                        case 'arrowdown': case 's': this.selectedOption = Math.min(this.options.length - 1, this.selectedOption + 1); break;
                        case 'enter': case ' ': this.options[this.selectedOption].action(); break;
                        case 'escape': case 'p': gameStates.currentState = gameStates.GAME; gamePaused = false; break;
                    }
                }
            },
            gameOverScreen: {
                draw: function() {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#ff5555'; 
                    ctx.font = `${Math.min(32, canvas.width / 20)}px "Press Start 2P"`; 
                    ctx.textAlign = 'center';
                    ctx.fillText("TIME'S UP!", canvas.width / 2, canvas.height / 3);
                    ctx.fillStyle = '#fff'; 
                    ctx.font = `${Math.min(20, canvas.width / 28)}px "Press Start 2P"`;
                    ctx.fillText(`Students Caught: ${player.captureCount} / ${students.length}`, canvas.width / 2, canvas.height / 2);
                    const minutes = Math.floor(gameTime / 60); const seconds = Math.floor(gameTime % 60);
                    ctx.fillText(`Time: ${minutes}:${seconds < 10 ? '0' : ''}${seconds}`, canvas.width / 2, canvas.height / 2 + Math.min(40, canvas.height/12));
                    ctx.fillStyle = '#ffcc00'; 
                    ctx.font = `${Math.min(16, canvas.width / 35)}px "Press Start 2P"`;
                    ctx.fillText("Press ENTER or Tap to retry", canvas.width / 2, canvas.height / 2 + Math.min(100, canvas.height/6));
                    ctx.fillText("Press ESC for main menu", canvas.width / 2, canvas.height / 2 + Math.min(130, canvas.height/5));
                },
                handleInput: function(key) {
                    switch(key.toLowerCase()) {
                        case 'enter': case ' ': gameStates.restartGame(); break;
                        case 'escape': gameStates.currentState = gameStates.MENU; gameTime = 0; break;
                    }
                }
            },
            victoryScreen: {
                draw: function() {
                    ctx.fillStyle = 'rgba(0, 0, 100, 0.3)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#fff';
                    // Simple particle effect for victory
                    for (let i = 0; i < 50; i++) { // Reduced particle count for performance
                        const x = (Math.sin(i * 0.1 + Date.now() * 0.0002) * 0.4 + 0.5) * canvas.width; // Slower movement
                        const y = (Math.cos(i * 0.1 + Date.now() * 0.0002) * 0.4 + 0.5) * canvas.height;
                        const size = Math.sin(i + Date.now() * 0.002) * 1.5 + 2; // Smaller particles
                        if (size > 0) ctx.fillRect(x, y, size, size);
                    }
                    ctx.shadowColor = '#ffff00'; ctx.shadowBlur = 15; ctx.fillStyle = '#ffff00';
                    ctx.font = `${Math.min(36, canvas.width / 18)}px "Press Start 2P"`; 
                    ctx.textAlign = 'center';
                    ctx.fillText("VICTORY!", canvas.width / 2, canvas.height / 3);
                    ctx.shadowBlur = 0; ctx.fillStyle = '#fff'; 
                    ctx.font = `${Math.min(20, canvas.width / 28)}px "Press Start 2P"`;
                    const minutes = Math.floor(gameTime / 60); const seconds = Math.floor(gameTime % 60);
                    ctx.fillText(`All students captured in ${minutes}:${seconds < 10 ? '0' : ''}${seconds}`, canvas.width / 2, canvas.height / 2);
                    ctx.fillStyle = '#ffcc00'; 
                    ctx.font = `${Math.min(16, canvas.width / 35)}px "Press Start 2P"`;
                    ctx.fillText("Press ENTER or Tap to play again", canvas.width / 2, canvas.height / 2 + Math.min(100, canvas.height/6));
                    ctx.fillText("Press ESC for main menu", canvas.width / 2, canvas.height / 2 + Math.min(130, canvas.height/5));
                },
                handleInput: function(key) {
                     switch(key.toLowerCase()) {
                        case 'enter': case ' ': gameStates.restartGame(); break;
                        case 'escape': gameStates.currentState = gameStates.MENU; gameTime = 0; break;
                    }
                }
            },
            startGame: function() {
                this.currentState = this.GAME; gamePaused = false;
                player.captureCount = 0; player.stamina = player.maxStamina;
                player.x = tables[KREMER_TABLE_INDEX].x + tables[KREMER_TABLE_INDEX].width / 2;
                player.y = tables[KREMER_TABLE_INDEX].y + tables[KREMER_TABLE_INDEX].height + TILE_SIZE * 2;
                player.targetX = player.x; player.targetY = player.y;
                player.dx = 0; player.dy = 0; player.radarActive = false; player.attractionField = false;
                specialAbilities.cooldown = 0; specialAbilities.active = false; specialAbilities.selectedAbility = 0;
                initializeStudents(); spawnPowerUps(); gameTime = 0;
                environment.timeOfDay = 0.25; // Start in morning
                updateCamera(); // Ensure camera is set correctly after player reset
                gameUI.classList.remove('hidden');
                gameUI.textContent = "Find and catch all your students!";
                setTimeout(() => gameUI.classList.add('hidden'), 3000);
            },
            restartGame: function() { this.startGame(); },
            showInstructionsScreen: function() { this.currentState = this.INSTRUCTIONS; },
            handleKeyPress: function(key) { // Centralized key press for non-game states
                switch(this.currentState) {
                    case this.MENU: this.startScreen.handleInput(key); break;
                    case this.INSTRUCTIONS: this.instructionsScreen.handleInput(key); break;
                    case this.PAUSED: this.pauseMenu.handleInput(key); break;
                    case this.GAME_OVER: this.gameOverScreen.handleInput(key); break;
                    case this.VICTORY: this.victoryScreen.handleInput(key); break;
                }
            },
            update: function() {
                if (this.currentState === this.GAME && !gamePaused) {
                    if (player.captureCount >= students.length && students.length > 0) { // Check against actual number of students
                        this.currentState = this.VICTORY;
                    }
                    const TIME_LIMIT = 5 * 60; // 5 minutes
                    if (gameTime > TIME_LIMIT && player.captureCount < students.length) {
                        this.currentState = this.GAME_OVER;
                    }
                }
            },
            draw: function() { // Centralized draw for non-game states
                 switch(this.currentState) {
                    case this.MENU: this.startScreen.draw(); break;
                    case this.INSTRUCTIONS: this.instructionsScreen.draw(); break;
                    case this.PAUSED: this.pauseMenu.draw(); break;
                    case this.GAME_OVER: this.gameOverScreen.draw(); break;
                    case this.VICTORY: this.victoryScreen.draw(); break;
                }
            }
        };

        function distance(obj1, obj2) {
            const centerX1 = obj1.x + obj1.width / 2; const centerY1 = obj1.y + obj1.height / 2;
            const centerX2 = obj2.x + obj2.width / 2; const centerY2 = obj2.y + obj2.height / 2;
            return Math.sqrt(Math.pow(centerX1 - centerX2, 2) + Math.pow(centerY1 - centerY2, 2));
        }

        function generateSeatPositions() {
            const table = tables[KREMER_TABLE_INDEX]; const seats = [];
            const spacing = TILE_SIZE * 1.5; const numSeatsAround = 15;
            // Seats above the table
            for (let i = 0; i < Math.floor(table.width / spacing) && seats.length < numSeatsAround; i++) seats.push({ x: table.x + i * spacing + TILE_SIZE * 0.25, y: table.y - TILE_SIZE * 1.5 });
            // Seats to the right of the table
            for (let i = 0; i < Math.floor(table.height / spacing) && seats.length < numSeatsAround; i++) seats.push({ x: table.x + table.width + TILE_SIZE, y: table.y + i * spacing + TILE_SIZE * 0.25 });
            // Seats below the table
            for (let i = 0; i < Math.floor(table.width / spacing) && seats.length < numSeatsAround; i++) seats.push({ x: table.x + i * spacing + TILE_SIZE * 0.25, y: table.y + table.height + TILE_SIZE * 0.5 });
            // Seats to the left of the table
            for (let i = 0; i < Math.floor(table.height / spacing) && seats.length < numSeatsAround; i++) seats.push({ x: table.x - TILE_SIZE * 1.5, y: table.y + i * spacing + TILE_SIZE * 0.25 });
            // Fallback for remaining seats if not enough space around table
            while (seats.length < numSeatsAround && seats.length < studentNames.length) seats.push({ x: table.x + getRandomInt(-5, 5) * TILE_SIZE, y: table.y + getRandomInt(-5, 5) * TILE_SIZE });
            return seats.slice(0, Math.min(numSeatsAround, studentNames.length));
        }
        const seatPositions = generateSeatPositions();

        function findValidPositions(count) {
            const positions = []; const minDistanceBetweenStudents = TILE_SIZE * 3;
            const kremerTable = tables[KREMER_TABLE_INDEX];
            const playerStartX = kremerTable.x + kremerTable.width / 2;
            const playerStartY = kremerTable.y + kremerTable.height + TILE_SIZE * 2;

            for (let i = 0; i < count; i++) {
                let studentX, studentY, validPosition; let attempts = 0;
                do {
                    attempts++; validPosition = true;
                    studentX = getRandomInt(TILE_SIZE * 2, WORLD_WIDTH - TILE_SIZE * 3);
                    studentY = getRandomInt(TILE_SIZE * 2, WORLD_HEIGHT - TILE_SIZE * 3);
                    // Check collision with any table (expanded check area)
                    for (const table of tables) if (checkCollision({x: studentX - TILE_SIZE, y: studentY - TILE_SIZE, width: TILE_SIZE * 3, height: TILE_SIZE * 3}, table)) { validPosition = false; break; }
                    if (validPosition) for (const pos of positions) if (Math.sqrt(Math.pow(studentX - pos.x, 2) + Math.pow(studentY - pos.y, 2)) < minDistanceBetweenStudents) { validPosition = false; break; }
                    // Check distance from player's starting position
                    if (Math.sqrt(Math.pow(studentX - playerStartX, 2) + Math.pow(studentY - playerStartY, 2)) < TILE_SIZE * 15) validPosition = false;
                    // Ensure not spawning on Ziv's table specifically
                    if (tables[1] && checkCollision({x: studentX, y: studentY, width: TILE_SIZE, height: TILE_SIZE}, tables[1])) validPosition = false;

                    if (attempts > 200) { // Fallback if too many attempts
                        studentX = getRandomInt(TILE_SIZE, WORLD_WIDTH - TILE_SIZE * 2); 
                        studentY = getRandomInt(TILE_SIZE, WORLD_HEIGHT - TILE_SIZE * 2); 
                        break; 
                    }
                } while (!validPosition);
                positions.push({x: studentX, y: studentY});
            }
            return positions;
        }
        
        function initializeStudents() {
            students.length = 0; // Clear existing students
            const numStudentsToSpawn = Math.min(15, studentNames.length, seatPositions.length);
            const validPositions = findValidPositions(numStudentsToSpawn);

            for (let i = 0; i < numStudentsToSpawn; i++) {
                students.push({
                    id: i, name: studentNames[i],
                    x: validPositions[i].x, y: validPositions[i].y,
                    width: TILE_SIZE, height: TILE_SIZE,
                    color: UNIFORM_STUDENT_COLOR, 
                    isCaught: false, isWandering: true, isAfraidOfTeacher: false,
                    wanderTargetX: validPositions[i].x, wanderTargetY: validPositions[i].y,
                    seatX: seatPositions[i].x, seatY: seatPositions[i].y,
                    speed: 1.5 + Math.random() * 0.5, runSpeed: 2.5 + Math.random() * 0.7, returnSpeed: 3,
                    wanderTimer: 0, wanderDelay: getRandomInt(60, 200), // Frames
                    lastDirection: { x: 0, y: 0 },
                    personality: { bravery: Math.random() * 0.6 + 0.2, intelligence: Math.random() * 0.7 + 0.1, stubbornness: Math.random() },
                    escapeTimer: 0, escapeFailCounter: 0, messageTimer: 0, currentMessage: "", frozenTimer: 0
                });
            }
        }

        function checkCollision(rect1, rect2) {
            if (!rect1 || !rect2) return false; // Safety check
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        function findPathAwayFromTeacher(student, teacher) {
            const dx = student.x - teacher.x; const dy = student.y - teacher.y;
            let targetX, targetY;

            if (student.personality.intelligence > 0.6) { // Smarter students try to hide
                let bestHidingSpot = null; let maxScore = -Infinity;
                tables.forEach(table => {
                    if (table === tables[KREMER_TABLE_INDEX]) return; // Don't hide at Kremer's table
                    const tableCenterX = table.x + table.width / 2; const tableCenterY = table.y + table.height / 2;
                    const teacherToTableX = tableCenterX - teacher.x; const teacherToTableY = tableCenterY - teacher.y;
                    const distTeacherToTable = Math.sqrt(teacherToTableX*teacherToTableX + teacherToTableY*teacherToTableY) || 1;
                    // Point behind the table relative to the teacher
                    const hideX = tableCenterX + (teacherToTableX / distTeacherToTable) * (table.width/2 + TILE_SIZE);
                    const hideY = tableCenterY + (teacherToTableY / distTeacherToTable) * (table.height/2 + TILE_SIZE);
                    const distStudentToHide = distance(student, {x: hideX, y: hideY, width:1, height:1});
                    let score = (1000 / (distStudentToHide + 1)) + distTeacherToTable; // Prioritize closer spots further from teacher
                    if (isPathBlocked(student.x, student.y, hideX, hideY)) score -= 500; // Penalize blocked paths
                    if (score > maxScore) { maxScore = score; bestHidingSpot = { x: hideX, y: hideY }; }
                });
                if (bestHidingSpot) { targetX = bestHidingSpot.x; targetY = bestHidingSpot.y; }
                else { // Fallback: simple flee
                    const escapeDist = TILE_SIZE * (10 + 5 * student.personality.bravery);
                    const currentDist = Math.sqrt(dx * dx + dy * dy) || 1;
                    targetX = student.x + (dx / currentDist) * escapeDist; targetY = student.y + (dy / currentDist) * escapeDist;
                }
            } else { // Less intelligent students just run directly away
                const escapeDist = TILE_SIZE * (10 + 5 * student.personality.bravery); // Braver students run further
                const currentDist = Math.sqrt(dx * dx + dy * dy) || 1; // Avoid division by zero
                targetX = student.x + (dx / currentDist) * escapeDist; targetY = student.y + (dy / currentDist) * escapeDist;
            }
            // Clamp target to world bounds
            targetX = Math.max(TILE_SIZE, Math.min(targetX, WORLD_WIDTH - TILE_SIZE * 2));
            targetY = Math.max(TILE_SIZE, Math.min(targetY, WORLD_HEIGHT - TILE_SIZE * 2));
            return { x: targetX, y: targetY };
        }

        function isPathBlocked(startX, startY, endX, endY) {
            const dist = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
            const steps = Math.max(1, Math.ceil(dist / (TILE_SIZE / 2))); // Check every half tile
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const checkX = startX + (endX - startX) * t; const checkY = startY + (endY - startY) * t;
                for (const table of tables) if (checkX >= table.x && checkX <= table.x + table.width && checkY >= table.y && checkY <= table.y + table.height) return true;
            }
            return false;
        }

        function findPathAroundObstacles(student, targetX, targetY) {
            // If direct path is clear, use it
            if (!isPathBlocked(student.x + student.width/2, student.y + student.height/2, targetX, targetY)) return { x: targetX, y: targetY };
            
            const possibleWaypoints = []; const checkAngles = 16; // Check 16 directions
            for (let i = 0; i < checkAngles; i++) {
                const angle = (i / checkAngles) * Math.PI * 2;
                const dist = TILE_SIZE * (5 + student.personality.intelligence * 5); // Smarter students look further
                const wpX = student.x + student.width/2 + Math.cos(angle) * dist; const wpY = student.y + student.height/2 + Math.sin(angle) * dist;
                
                if (wpX > 0 && wpX < WORLD_WIDTH && wpY > 0 && wpY < WORLD_HEIGHT && 
                    !isPathBlocked(student.x + student.width/2, student.y + student.height/2, wpX, wpY)) {
                    const distToTarget = Math.sqrt(Math.pow(wpX - targetX, 2) + Math.pow(wpY - targetY, 2));
                    const directDistToTarget = Math.sqrt(Math.pow(student.x - targetX, 2) + Math.pow(student.y - targetY, 2));
                    // Score waypoints: lower is better for distToTarget, also prefer waypoints that make progress
                    const score = distToTarget + Math.abs(directDistToTarget - distToTarget) * 0.5; // Heuristic
                    possibleWaypoints.push({ x: wpX, y: wpY, score: score });
                }
            }
            if (possibleWaypoints.length > 0) { 
                possibleWaypoints.sort((a, b) => a.score - b.score); // Sort by best score (lowest)
                return possibleWaypoints[0]; 
            }
            return { x: targetX, y: targetY }; // Fallback: original target if no good waypoint
        }

        function spawnPowerUps() {
            powerUps.length = 0; // Clear existing powerups
            const maxPowerUps = 5;
            const count = Math.min(maxPowerUps, (students.length - player.captureCount) / 2); // Spawn fewer if fewer students left

            for (let i = 0; i < count; i++) {
                let x, y, validPosition; let attempts = 0;
                do {
                    validPosition = true; attempts++;
                    x = getRandomInt(TILE_SIZE * 2, WORLD_WIDTH - TILE_SIZE * 3); y = getRandomInt(TILE_SIZE * 2, WORLD_HEIGHT - TILE_SIZE * 3);
                    const tempPowerUp = {x, y, width: TILE_SIZE, height: TILE_SIZE};
                    // Check collision with tables (expanded check area to avoid spawning too close)
                    for (const table of tables) if (checkCollision(tempPowerUp, {x: table.x - TILE_SIZE, y: table.y - TILE_SIZE, width: table.width + TILE_SIZE*2, height: table.height + TILE_SIZE*2})) { validPosition = false; break; }
                    if (validPosition) for (const pUp of powerUps) if (distance(tempPowerUp, pUp) < TILE_SIZE * 8) { validPosition = false; break; } // Min distance between powerups
                    
                    // Avoid spawning too close to player's start
                    const kremerTable = tables[KREMER_TABLE_INDEX];
                    const playerStartX = kremerTable.x + kremerTable.width / 2; const playerStartY = kremerTable.y + kremerTable.height + TILE_SIZE * 2;
                    if (distance(tempPowerUp, {x:playerStartX, y:playerStartY, width:1, height:1}) < TILE_SIZE * 10) validPosition = false;
                    
                    if (attempts > 100) break; // Prevent infinite loop
                } while (!validPosition);

                if (validPosition) {
                    const type = powerUpTypes[getRandomInt(0, powerUpTypes.length - 1)];
                    powerUps.push({ x, y, width: TILE_SIZE, height: TILE_SIZE, type, pulseTimer: Math.random() * Math.PI * 2 });
                }
            }
        }

        function updatePowerUps() {
            if (gamePaused) return;
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const powerUp = powerUps[i]; powerUp.pulseTimer += 0.05; // For pulsing animation
                if (checkCollision(player, powerUp)) {
                    powerUp.type.effect();
                    powerUps.splice(i, 1); // Remove collected power-up
                }
            }
            // Occasionally spawn new power-ups if few are left
            if (powerUps.length < 2 && Math.random() < 0.002 && (students.length - player.captureCount > 0) ) spawnPowerUps();
        }

        function updateCamera() {
            // Camera follows player with a slight lag
            const targetCamX = player.x - camera.width / (2 * camera.zoom) + player.width / 2;
            const targetCamY = player.y - camera.height / (2 * camera.zoom) + player.height / 2;
            camera.x += (targetCamX - camera.x) * 0.08; // Smoothing factor
            camera.y += (targetCamY - camera.y) * 0.08;

            // Keep camera within world bounds
            camera.x = Math.max(0, Math.min(camera.x, WORLD_WIDTH - camera.width / camera.zoom));
            camera.y = Math.max(0, Math.min(camera.y, WORLD_HEIGHT - camera.height / camera.zoom));
        }

        function updatePlayer() {
            if (gamePaused) return;

            // Handle sprinting and stamina
            if (player.isSprinting && keys.shift && player.stamina > 0) {
                player.currentSpeed = player.baseSpeed * player.sprintMultiplier;
                player.stamina = Math.max(0, player.stamina - player.staminaDepletionRate);
                if (player.stamina <= 0) player.isSprinting = false; // Auto-stop sprint if out of stamina
            } else {
                player.currentSpeed = player.baseSpeed;
                player.isSprinting = false; // Ensure isSprinting is false if not actively sprinting
                if (player.stamina < player.maxStamina) player.stamina = Math.min(player.maxStamina, player.stamina + player.staminaRegenRate);
            }

            let moveDeltaX = 0; let moveDeltaY = 0;
            if (player.dx !== 0 || player.dy !== 0) { // Only calculate if there's directional input
                moveDeltaX = player.dx * player.currentSpeed; 
                moveDeltaY = player.dy * player.currentSpeed;
            }
            
            player.targetX = player.x + moveDeltaX; 
            player.targetY = player.y + moveDeltaY;

            // Smooth movement
            const smoothDx = player.targetX - player.x;
            const smoothDy = player.targetY - player.y;
            if (Math.abs(smoothDx) > 0.1 || Math.abs(smoothDy) > 0.1) { // Apply smoothing if movement is significant
                player.x += smoothDx * player.movementSmoothing;
                player.y += smoothDy * player.movementSmoothing;
            } else { // Snap to target if very close to avoid jitter
                player.x = player.targetX;
                player.y = player.targetY;
            }

            // World boundary collision
            player.x = Math.max(0, Math.min(player.x, WORLD_WIDTH - player.width));
            player.y = Math.max(0, Math.min(player.y, WORLD_HEIGHT - player.height));

            // Obstacle collision (tables)
            for (const table of tables) {
                if (checkCollision(player, table)) {
                    // Determine overlap on each side
                    const overlapLeft = (player.x + player.width) - table.x;
                    const overlapRight = (table.x + table.width) - player.x;
                    const overlapTop = (player.y + player.height) - table.y;
                    const overlapBottom = (table.y + table.height) - player.y;

                    const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

                    // Push player out of the table based on the smallest overlap
                    if (minOverlap === overlapLeft) player.x = table.x - player.width;
                    else if (minOverlap === overlapRight) player.x = table.x + table.width;
                    else if (minOverlap === overlapTop) player.y = table.y - player.height;
                    else if (minOverlap === overlapBottom) player.y = table.y + table.height;
                    
                    player.targetX = player.x; // Stop further movement into the obstacle
                    player.targetY = player.y;
                }
            }
        }

        function updateStudents() {
            if (gamePaused) return;
            students.forEach(student => {
                if (student.frozenTimer && student.frozenTimer > 0) { student.frozenTimer--; return; } // Skip movement if frozen

                if (student.isCaught) {
                    // Move student to their designated seat
                    const targetX = student.seatX; const targetY = student.seatY;
                    const diffX = targetX - student.x; const diffY = targetY - student.y;
                    const distToSeat = Math.sqrt(diffX * diffX + diffY * diffY);

                    if (distToSeat < student.returnSpeed) { student.x = targetX; student.y = targetY; } // Snap to seat if close
                    else {
                        let moveX = (diffX / distToSeat) * student.returnSpeed; 
                        let moveY = (diffY / distToSeat) * student.returnSpeed;
                        let nextX = student.x + moveX; let nextY = student.y + moveY;
                        
                        // Simple collision avoidance while returning (try to slide along obstacles)
                        for (const table of tables) {
                            if (checkCollision({ ...student, x: nextX, y: nextY }, table)) {
                                if (Math.abs(diffX) > Math.abs(diffY)) { // Prefer vertical detour if horizontal collision
                                     if (!isPathBlocked(student.x, student.y, student.x, student.y + Math.sign(diffY) * student.returnSpeed)) { moveX = 0; moveY = Math.sign(diffY) * student.returnSpeed * 0.8; }
                                } else { // Prefer horizontal detour if vertical collision
                                     if (!isPathBlocked(student.x, student.y, student.x + Math.sign(diffX) * student.returnSpeed, student.y)) { moveX = Math.sign(diffX) * student.returnSpeed * 0.8; moveY = 0; }
                                }
                                break;
                            }
                        }
                        student.x += moveX; student.y += moveY;
                    }
                } else { // Student is not caught
                    // Attraction field effect
                    if (player.attractionField) {
                        const distToPlayer = distance(student, player);
                        if (distToPlayer < player.attractionRadius) {
                            const force = (1 - distToPlayer / player.attractionRadius) * player.attractionForce;
                            const dirX = player.x - student.x; const dirY = player.y - student.y;
                            const len = Math.sqrt(dirX * dirX + dirY * dirY) || 1;
                            student.x += (dirX / len) * force * student.speed * 0.5; 
                            student.y += (dirY / len) * force * student.speed * 0.5;
                        }
                    }

                    const distToTeacher = distance(student, player);
                    // Check if student sees the teacher
                    if (distToTeacher < DETECTION_RADIUS && !student.isAfraidOfTeacher) {
                        if (Math.random() > student.personality.bravery) { // Braver students are less likely to get scared
                            student.isAfraidOfTeacher = true; student.isWandering = false;
                            student.currentMessage = "!"; student.messageTimer = 60; // Show "!" for 1 second
                        }
                    } else if (distToTeacher >= DETECTION_RADIUS * 1.5 && student.isAfraidOfTeacher) { // Student might calm down if teacher is far
                        if (Math.random() < 0.05 / (student.personality.stubbornness + 0.1)) { // Stubborn students stay scared longer
                            student.isAfraidOfTeacher = false; student.isWandering = true; student.wanderTimer = student.wanderDelay; // Reset wander
                        }
                    }
                    if (student.messageTimer > 0) student.messageTimer--; else student.currentMessage = "";

                    if (student.isAfraidOfTeacher) {
                        // Student is scared, try to run away
                        const escapeTarget = findPathAwayFromTeacher(student, player);
                        const finalPathTarget = findPathAroundObstacles(student, escapeTarget.x, escapeTarget.y);
                        const diffX = finalPathTarget.x - student.x; const diffY = finalPathTarget.y - student.y;
                        const distToTarget = Math.sqrt(diffX * diffX + diffY * diffY);

                        if (distToTarget > student.runSpeed) {
                            let moveX = (diffX / distToTarget) * student.runSpeed; let moveY = (diffY / distToTarget) * student.runSpeed;
                            // Add some inertia/smoothing to movement
                            moveX = moveX * 0.8 + student.lastDirection.x * 0.2; 
                            moveY = moveY * 0.8 + student.lastDirection.y * 0.2;
                            const moveLen = Math.sqrt(moveX*moveX + moveY*moveY) || 1;
                            if (moveLen > student.runSpeed) { moveX = (moveX/moveLen) * student.runSpeed; moveY = (moveY/moveLen) * student.runSpeed; }
                            student.lastDirection = { x: moveX, y: moveY };

                            let nextX = student.x + moveX; let nextY = student.y + moveY; let collided = false;
                            for (const table of tables) if (checkCollision({ ...student, x: nextX, y: nextY }, table)) { 
                                collided = true; 
                                student.x -= moveX * 0.5; student.y -= moveY * 0.5; // Bounce back slightly
                                student.lastDirection = {x: -student.lastDirection.x *0.5 , y: -student.lastDirection.y*0.5}; // Change direction
                                student.escapeFailCounter++; 
                                if(student.escapeFailCounter > 5) { // If stuck too many times, try to unstick
                                    student.isAfraidOfTeacher = false; student.isWandering = true; student.wanderTimer = 0; student.escapeFailCounter = 0; 
                                }
                                break; 
                            }
                            if (!collided) { student.x = nextX; student.y = nextY; student.escapeFailCounter = 0; }
                        } else { // Reached escape target or very close
                            student.escapeTimer++; if(student.escapeTimer > 120) { // If "safe" for a while, may calm down
                                student.isAfraidOfTeacher = false; student.isWandering = true; student.escapeTimer = 0;
                            }
                        }
                        student.x = Math.max(0, Math.min(student.x, WORLD_WIDTH - student.width)); 
                        student.y = Math.max(0, Math.min(student.y, WORLD_HEIGHT - student.height));
                    } else if (student.isWandering) {
                        // Student is wandering around
                        student.wanderTimer++;
                        if (student.wanderTimer >= student.wanderDelay || distance(student, {x: student.wanderTargetX, y: student.wanderTargetY, width:1, height:1}) < student.speed * 2) { // New target if timer up or reached current
                            student.wanderTimer = 0; student.wanderDelay = getRandomInt(100, 300); // New delay
                            const angle = Math.random() * Math.PI * 2; const wanderDist = TILE_SIZE * getRandomInt(5, 15);
                            student.wanderTargetX = student.x + Math.cos(angle) * wanderDist; 
                            student.wanderTargetY = student.y + Math.sin(angle) * wanderDist;
                            // Clamp wander target to world bounds
                            student.wanderTargetX = Math.max(TILE_SIZE, Math.min(student.wanderTargetX, WORLD_WIDTH - TILE_SIZE*2));
                            student.wanderTargetY = Math.max(TILE_SIZE, Math.min(student.wanderTargetY, WORLD_HEIGHT - TILE_SIZE*2));
                        }
                        const diffX = student.wanderTargetX - student.x; const diffY = student.wanderTargetY - student.y;
                        const distToTarget = Math.sqrt(diffX * diffX + diffY * diffY);

                        if (distToTarget > student.speed) {
                            let moveX = (diffX / distToTarget) * student.speed; let moveY = (diffY / distToTarget) * student.speed;
                            // Smoothing/inertia for wander
                            moveX = moveX * 0.7 + student.lastDirection.x * 0.3; 
                            moveY = moveY * 0.7 + student.lastDirection.y * 0.3;
                            const moveLen = Math.sqrt(moveX*moveX + moveY*moveY) || 1;
                            if (moveLen > student.speed) { moveX = (moveX/moveLen) * student.speed; moveY = (moveY/moveLen) * student.speed; }
                            student.lastDirection = { x: moveX, y: moveY };

                            let nextX = student.x + moveX; let nextY = student.y + moveY; let collision = false;
                            const futureStudent = { ...student, x: nextX, y: nextY };
                            // Check collision with tables
                            for (const table of tables) if (checkCollision(futureStudent, table)) { collision = true; break; }
                            // Check collision with other non-caught students (simple sphere check)
                            for (const otherStudent of students) if (student.id !== otherStudent.id && !otherStudent.isCaught && distance(futureStudent, otherStudent) < TILE_SIZE * 1.5) { collision = true; break; }
                            
                            if (!collision) { student.x = nextX; student.y = nextY; } 
                            else { student.wanderTimer = student.wanderDelay; student.lastDirection = {x:0, y:0}; } // New target if collided
                        } else student.wanderTimer = student.wanderDelay; // Reached target, get new one next frame

                        student.x = Math.max(0, Math.min(student.x, WORLD_WIDTH - student.width)); 
                        student.y = Math.max(0, Math.min(student.y, WORLD_HEIGHT - student.height));
                    }

                    // Check for capture
                    if (distance(player, student) < CAPTURE_RADIUS && !student.isCaught) {
                        student.isCaught = true; student.isWandering = false; student.isAfraidOfTeacher = false;
                        player.captureCount++;
                        gameUI.classList.remove('hidden');
                        gameUI.textContent = `${student.name} caught! (${player.captureCount}/${students.length})`;
                        setTimeout(() => gameUI.classList.add('hidden'), 2000);
                    }
                }
            });
        }

        function updateGameTime() {
            if (!gamePaused) gameTime += 1/60; // Assuming 60 FPS
        }

        function update() {
            if (gameStates.currentState === gameStates.GAME && !gamePaused) {
                environment.updateEnvironment(); 
                specialAbilities.update();
                updatePlayer(); 
                updateStudents(); 
                updatePowerUps();
                updateCamera(); 
                updateGameTime();
            }
            gameStates.update(); // Update current game state (checks for win/loss)
        }
        
        // --- Drawing Functions ---
        function drawRect(x, y, width, height, color) {
            ctx.fillStyle = color; ctx.fillRect(x, y, width, height);
        }
        function drawText(text, x, y, color = '#fff', size = 10, align = 'center') {
            ctx.fillStyle = color; ctx.font = `${size}px 'Press Start 2P'`; ctx.textAlign = align; ctx.fillText(text, x, y);
        }
        function drawCircle(x, y, radius, color) {
            ctx.fillStyle = color; ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI * 2); ctx.fill();
        }
        function drawGrid() {
            ctx.strokeStyle = 'rgba(58, 58, 58, 0.5)'; ctx.lineWidth = 0.5; const gridSize = TILE_SIZE * 5;
            // Only draw grid visible in camera
            const startX = Math.floor(camera.x / gridSize) * gridSize; 
            const endX = Math.ceil((camera.x + camera.width / camera.zoom) / gridSize) * gridSize;
            const startY = Math.floor(camera.y / gridSize) * gridSize; 
            const endY = Math.ceil((camera.y + camera.height / camera.zoom) / gridSize) * gridSize;

            for (let gx = startX; gx < endX; gx += gridSize) { ctx.beginPath(); ctx.moveTo(gx, startY); ctx.lineTo(gx, endY); ctx.stroke(); }
            for (let gy = startY; gy < endY; gy += gridSize) { ctx.beginPath(); ctx.moveTo(startX, gy); ctx.lineTo(endX, gy); ctx.stroke(); }
        }

        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas
            ctx.save(); // Save current context state
            ctx.scale(camera.zoom, camera.zoom); // Apply camera zoom
            ctx.translate(-camera.x, -camera.y); // Apply camera pan

            // Draw background based on environment
            const bgColor = environment.getBackgroundColor();
            ctx.fillStyle = bgColor; 
            ctx.fillRect(camera.x, camera.y, camera.width / camera.zoom, camera.height / camera.zoom); // Fill visible area
            
            ctx.globalAlpha = environment.getLightLevel(); // Apply light level
            drawGrid();

            // Draw tables
            tables.forEach(table => {
                drawRect(table.x, table.y, table.width, table.height, table.color);
                if (table.name === "Dining Table") {
                    const tabletopPadding = TILE_SIZE * 0.2;
                    ctx.fillStyle = 'rgba(0,0,0,0.15)'; 
                    ctx.fillRect(table.x + tabletopPadding, table.y + tabletopPadding, 
                                 table.width - 2 * tabletopPadding, table.height - 2 * tabletopPadding);
                    const benchColor = '#A0522D'; 
                    const benchThickness = TILE_SIZE * 0.75;
                    const benchOffset = TILE_SIZE * 0.2;
                    if (table.width > table.height) { // Horizontal table
                        drawRect(table.x, table.y - benchThickness - benchOffset, table.width, benchThickness, benchColor);
                        drawRect(table.x, table.y + table.height + benchOffset, table.width, benchThickness, benchColor);
                    } else { // Vertical table
                        drawRect(table.x - benchThickness - benchOffset, table.y, benchThickness, table.height, benchColor);
                        drawRect(table.x + table.width + benchOffset, table.y, benchThickness, table.height, benchColor);
                    }
                } else if (table.name !== "Obstacle") {
                    drawText(table.name, table.x + table.width / 2, table.y + table.height / 2 - 5, '#eee', 8);
                }
            });

            // Draw Ziv
            drawRect(ziv.x, ziv.y, ziv.width, ziv.height, ziv.color);
            drawText(ziv.name, ziv.x + ziv.width / 2, ziv.y - 6, '#fff', 8);

            // Draw seats and caught students at seats
            seatPositions.forEach((seat) => {
                const studentAtSeat = students.find(s => s.isCaught && Math.abs(s.x - seat.x) < TILE_SIZE/2 && Math.abs(s.y - seat.y) < TILE_SIZE/2);
                if (studentAtSeat) {
                    drawRect(seat.x, seat.y, TILE_SIZE, TILE_SIZE, studentAtSeat.color);
                    drawText(studentAtSeat.name.substring(0,3), seat.x + TILE_SIZE / 2, seat.y - 6, '#fff', 7);
                } else drawRect(seat.x, seat.y, TILE_SIZE, TILE_SIZE, '#555'); // Empty seat
            });

            // Draw power-ups
            powerUps.forEach(powerUp => {
                const pulseScale = 0.8 + Math.sin(powerUp.pulseTimer) * 0.2; const size = TILE_SIZE * pulseScale;
                const pX = powerUp.x + TILE_SIZE/2; const pY = powerUp.y + TILE_SIZE/2;
                // Outer glow
                ctx.globalAlpha = environment.getLightLevel() * (0.3 + Math.sin(powerUp.pulseTimer * 1.5) * 0.2);
                drawCircle(pX, pY, size/2 * 1.5, powerUp.type.color);
                // Inner circle
                ctx.globalAlpha = environment.getLightLevel();
                drawCircle(pX, pY, size/2, powerUp.type.color);
                drawText(powerUp.type.name.charAt(0), pX, pY + 4, '#fff', 12); // Letter indication
            });

            // Draw students
            students.forEach(s => {
                // Draw student if not caught OR if caught but not yet at their seat
                if (!s.isCaught || (s.isCaught && (Math.abs(s.x - s.seatX) > 1 || Math.abs(s.y - s.seatY) > 1))) {
                    drawRect(s.x, s.y, s.width, s.height, s.color);
                    drawText(s.name.substring(0,3), s.x + s.width / 2, s.y - 6, '#fff', 7); // Student name abbreviation
                    if (s.currentMessage && s.messageTimer > 0) drawText(s.currentMessage, s.x + s.width / 2, s.y - 15, '#ffcc00', 12);
                    else if (s.isAfraidOfTeacher) drawText("!", s.x + s.width / 2, s.y - 15, '#ff3333', 12); // Exclamation mark if scared

                    // Radar effect
                    if (player.radarActive && !s.isCaught) {
                        const dist = distance(player, s); const maxRadarDist = TILE_SIZE * 40;
                        if (dist < maxRadarDist) {
                            const radarIntensity = Math.max(0.2, 1 - dist / maxRadarDist);
                            const pulseSize = (4 + Math.sin(gameTime * 8 + s.id) * 2) * radarIntensity;
                            drawCircle(s.x + s.width / 2, s.y + s.height / 2, pulseSize, `rgba(255, 100, 100, ${radarIntensity * 0.7})`);
                        }
                    }
                    // Frozen effect
                    if (s.frozenTimer && s.frozenTimer > 0) {
                        ctx.fillStyle = `rgba(173, 216, 230, ${0.3 + (s.frozenTimer % 60) / 120})`; // Pulsing blue overlay
                        ctx.fillRect(s.x - 2, s.y - 2, s.width + 4, s.height + 4);
                        ctx.fillStyle = 'rgba(220, 250, 255, 0.6)'; // Ice particles
                        for(let k=0; k<3; k++) drawRect(s.x + Math.random()*s.width - 2, s.y + Math.random()*s.height - 2, 4, 4, ctx.fillStyle);
                    }
                }
            });

            // Draw player
            drawRect(player.x, player.y, player.width, player.height, player.color);
            drawText(player.name, player.x + player.width / 2, player.y - 6, '#fff', 8);
            // Attraction field visual
            if (player.attractionField) {
                const pulse = Math.sin(gameTime * 6) * 0.1;
                ctx.strokeStyle = `rgba(255, 0, 204, ${0.3 + pulse * 0.2})`; ctx.lineWidth = 2 + pulse;
                ctx.beginPath(); ctx.arc(player.x + player.width/2, player.y + player.height/2, player.attractionRadius * (0.9 + pulse * 0.05) , 0, Math.PI * 2); ctx.stroke();
            }
            
            ctx.globalAlpha = 1; // Reset global alpha before restoring
            ctx.restore(); // Restore context state (removes camera transforms and globalAlpha)
            
            drawUI(); // Draw UI elements on top, not affected by camera
        }

        function drawUI() {
            const barWidth = Math.min(150, canvas.width * 0.25); // Responsive bar width
            const barHeight = Math.min(15, canvas.height * 0.03);
            const padding = Math.min(10, canvas.width * 0.02); // Responsive padding
            const fontSizeSmall = Math.max(8, Math.min(10, canvas.width / 60)); // Responsive font size
            const fontSizeMedium = Math.max(10, Math.min(12, canvas.width / 50));

            // Stamina Bar
            drawRect(padding, padding, barWidth, barHeight, 'rgba(0,0,0,0.5)');
            const staminaWidth = (player.stamina / player.maxStamina) * (barWidth - 4); // Inner bar padding
            ctx.fillStyle = player.isSprinting ? '#ff9900' : '#22cc22';
            ctx.fillRect(padding + 2, padding + 2, staminaWidth > 0 ? staminaWidth : 0, barHeight - 4);

            // Ability Cooldown Bar
            const abilityBarY = padding + barHeight + padding / 2;
            drawRect(padding, abilityBarY, barWidth, barHeight, 'rgba(0,0,0,0.5)');
            const cooldownWidth = (1 - specialAbilities.cooldown / specialAbilities.maxCooldown) * (barWidth - 4);
            ctx.fillStyle = specialAbilities.cooldown === 0 ? '#22aaff' : '#aaaaaa';
            ctx.fillRect(padding + 2, abilityBarY + 2, cooldownWidth > 0 ? cooldownWidth : 0, barHeight - 4);
            
            // Ability Name
            drawText(specialAbilities.available[specialAbilities.selectedAbility].name, padding + barWidth + padding, abilityBarY + barHeight/2 + fontSizeSmall/2, '#fff', fontSizeSmall, 'left');

            // Students Caught
            const studentsTextY = abilityBarY + barHeight + padding;
            drawText(`Students: ${player.captureCount}/${students.length}`, padding, studentsTextY, '#fff', fontSizeMedium, 'left');

            // Game Time
            const gameTimeTextY = studentsTextY + fontSizeMedium + padding / 2;
            const minutes = Math.floor(gameTime / 60); const seconds = Math.floor(gameTime % 60);
            drawText(`Time: ${minutes}:${seconds < 10 ? '0' : ''}${seconds}`, padding, gameTimeTextY, '#fff', fontSizeMedium, 'left');

            // In-Game Time of Day (Top Right)
            drawText(`Day Time: ${Math.floor(environment.timeOfDay*24)}:00`, canvas.width - padding, padding + fontSizeSmall, '#fff', fontSizeSmall, 'right');
            
            // Controls Hint (Bottom Center, disappears after a while)
            if (gameTime < 10 && gameStates.currentState === gameStates.GAME) {
                const hintText = (window.innerWidth < 768) ? 'Drag:Move, Tap Zones:Sprint/Ability' : 'WASD/Arrows:Move, SHIFT:Sprint, SPACE:Ability, Q:Cycle, P:Pause';
                drawText(hintText, canvas.width / 2, canvas.height - padding, '#ccc', fontSizeSmall);
            }
        }

        function draw() {
            if (gameStates.currentState === gameStates.GAME) drawGame();
            else gameStates.draw(); // Draw menus/screens
        }

        function gameLoop() { 
            update(); 
            draw(); 
            requestAnimationFrame(gameLoop); 
        }

        // --- Input Handling ---
        const keys = { up: false, down: false, left: false, right: false, shift: false, space: false, q: false, p: false, enter: false, escape: false };

        function handleKeyDown(e) {
            const key = e.key.toLowerCase();
            // Handle input for non-game states (menus, etc.)
            if (gameStates.currentState !== gameStates.GAME) { 
                gameStates.handleKeyPress(e.key); // Pass original key for case sensitivity if needed by menu
                return; 
            }
            // Prevent default for game control keys
            if (["arrowup", "arrowdown", "arrowleft", "arrowright", "w", "a", "s", "d", "shift", " ", "q", "p", "escape"].includes(key)) e.preventDefault();
            
            switch (key) {
                case 'arrowup': case 'w': keys.up = true; break;
                case 'arrowdown': case 's': keys.down = true; break;
                case 'arrowleft': case 'a': keys.left = true; break;
                case 'arrowright': case 'd': keys.right = true; break;
                case 'shift': keys.shift = true; player.isSprinting = true; break;
                case ' ': keys.space = true; specialAbilities.activateAbility(); break; // Space for ability
                case 'q': keys.q = true; specialAbilities.cycleAbility(); break;
                case 'p': 
                    if (gameStates.currentState === gameStates.GAME) { 
                        gamePaused = !gamePaused; 
                        if (gamePaused) gameStates.currentState = gameStates.PAUSED;
                        // else gameStates.currentState = gameStates.GAME; // Already handled by pauseMenu resume
                    } 
                    break;
                case 'escape': 
                    if (gameStates.currentState === gameStates.GAME) { 
                        gamePaused = true; gameStates.currentState = gameStates.PAUSED; 
                    } 
                    break;
            }
            if (gameStates.currentState === gameStates.GAME) updatePlayerVelocity();
        }
        function handleKeyUp(e) {
            const key = e.key.toLowerCase();
            if (gameStates.currentState !== gameStates.GAME) return; // Only handle game keys
            switch (key) {
                case 'arrowup': case 'w': keys.up = false; break;
                case 'arrowdown': case 's': keys.down = false; break;
                case 'arrowleft': case 'a': keys.left = false; break;
                case 'arrowright': case 'd': keys.right = false; break;
                case 'shift': keys.shift = false; player.isSprinting = false; break;
                case ' ': keys.space = false; break; 
                case 'q': keys.q = false; break;
            }
            if (gameStates.currentState === gameStates.GAME) updatePlayerVelocity();
        }
        function updatePlayerVelocity() {
            player.dx = 0; player.dy = 0;
            if (keys.up) player.dy = -1; if (keys.down) player.dy = 1;
            if (keys.left) player.dx = -1; if (keys.right) player.dx = 1;
            // Normalize diagonal movement
            if (player.dx !== 0 && player.dy !== 0) { 
                const length = Math.sqrt(player.dx * player.dx + player.dy * player.dy); 
                player.dx /= length; player.dy /= length; 
            }
        }
        document.addEventListener('keydown', handleKeyDown); 
        document.addEventListener('keyup', handleKeyUp);

        // --- Touch Controls ---
        let touchStartX = 0; let touchStartY = 0; const touchThreshold = 15; // Slightly smaller threshold for responsiveness
        let lastTapTime = 0; const doubleTapThreshold = 300; // ms for double tap
        let isDragging = false;

        canvas.addEventListener('touchstart', function(e) {
            e.preventDefault(); // Crucial for preventing unwanted browser behavior on mobile
            const touch = e.touches[0];
            
            if (gameStates.currentState !== gameStates.GAME) {
                const canvasRect = canvas.getBoundingClientRect();
                // Convert touch coordinates to canvas relative coordinates
                const touchX = touch.clientX - canvasRect.left;
                const touchY = touch.clientY - canvasRect.top;

                if (gameStates.currentState === gameStates.MENU || gameStates.currentState === gameStates.PAUSED) {
                    let menuSystem = (gameStates.currentState === gameStates.MENU) ? gameStates.startScreen : gameStates.pauseMenu;
                    const optionHeight = Math.min(50, canvas.height / 10); // Use responsive height from draw
                    const firstOptionYBase = (gameStates.currentState === gameStates.MENU) ? canvas.height / 2 + Math.min(30, canvas.height / 15) : canvas.height / 2;
                    
                    for(let i=0; i < menuSystem.options.length; i++) {
                        const optionCenterY = firstOptionYBase + i * optionHeight;
                        const optionTopY = optionCenterY - optionHeight / 2;
                        const optionBottomY = optionCenterY + optionHeight / 2;
                        // Check if touch is within the vertical bounds of an option (full width tap)
                        if (touchY > optionTopY && touchY < optionBottomY) {
                            menuSystem.selectedOption = i;
                            menuSystem.handleInput('enter'); // Simulate enter press
                            return;
                        }
                    }
                } else if (gameStates.currentState === gameStates.INSTRUCTIONS || gameStates.currentState === gameStates.GAME_OVER || gameStates.currentState === gameStates.VICTORY) {
                    // Simple tap anywhere to proceed on these screens
                    gameStates.handleKeyPress('enter');
                }
                return;
            }
            // In-game touch controls
            isDragging = true;
            touchStartX = touch.clientX; touchStartY = touch.clientY;
            
            const now = Date.now();
            // Double tap in the center-ish area for ability activation
            const rect = canvas.getBoundingClientRect();
            const tapX = touch.clientX - rect.left;
            const tapY = touch.clientY - rect.top;

            if (tapX > canvas.width * 0.3 && tapX < canvas.width * 0.7 &&
                tapY > canvas.height * 0.3 && tapY < canvas.height * 0.7) { // Central area for double tap
                if (now - lastTapTime < doubleTapThreshold) { 
                    specialAbilities.activateAbility(); 
                    lastTapTime = 0; // Reset last tap time to prevent triple taps activating again
                } else {
                    lastTapTime = now;
                }
            } else { // If tap is outside central area, reset double tap timer
                 lastTapTime = now; // Still record this tap for next potential double tap
            }


            // Sprint: Bottom-right corner (approx last 30% width and height)
            if (touch.clientX > rect.left + canvas.width * 0.7 && touch.clientY > rect.top + canvas.height * 0.7) { 
                keys.shift = true; player.isSprinting = true; 
            }
            // Cycle Ability: Bottom-left corner
            if (touch.clientX < rect.left + canvas.width * 0.3 && touch.clientY > rect.top + canvas.height * 0.7) {
                specialAbilities.cycleAbility();
            }
            updatePlayerVelocity(); // Update velocity based on initial touch if needed (though drag is primary)
        }, { passive: false });

        canvas.addEventListener('touchmove', function(e) {
            if (gameStates.currentState !== gameStates.GAME || gamePaused || !isDragging) return; 
            e.preventDefault();
            const touch = e.touches[0]; 
            const diffX = touch.clientX - touchStartX; 
            const diffY = touch.clientY - touchStartY;

            // Determine primary direction of drag
            if (Math.abs(diffX) > touchThreshold || Math.abs(diffY) > touchThreshold) {
                player.dx = 0; player.dy = 0; // Reset before setting
                if (Math.abs(diffX) > Math.abs(diffY)) { // Horizontal movement is dominant
                    player.dx = (diffX > 0) ? 1 : -1;
                } else { // Vertical movement is dominant
                    player.dy = (diffY > 0) ? 1 : -1;
                }
                // If significant movement in both, allow diagonal (already handled by updatePlayerVelocity normalization)
                 if (Math.abs(diffX) > touchThreshold && Math.abs(diffY) > touchThreshold) {
                    player.dx = (diffX > 0) ? 1 : -1;
                    player.dy = (diffY > 0) ? 1 : -1;
                }
            } else { // If not enough movement, no direction change
                player.dx = 0; player.dy = 0;
            }
            updatePlayerVelocity();
        }, { passive: false });

        canvas.addEventListener('touchend', function(e) {
            if (gameStates.currentState !== gameStates.GAME) return;
            isDragging = false;
            keys.up = false; keys.down = false; keys.left = false; keys.right = false; // Stop movement
            player.dx = 0; player.dy = 0; // Explicitly stop player velocity components

            // Check if any remaining touches are still in the sprint zone
            let stillSprinting = false;
            if (e.touches.length > 0) {
                const rect = canvas.getBoundingClientRect();
                for (let i = 0; i < e.touches.length; i++) {
                    const touch = e.touches[i];
                     if (touch.clientX > rect.left + canvas.width * 0.7 && touch.clientY > rect.top + canvas.height * 0.7) {
                        stillSprinting = true;
                        break;
                    }
                }
            }
            if (!stillSprinting) {
                keys.shift = false; player.isSprinting = false;
            }
            updatePlayerVelocity();
        });

        // --- Game Initialization ---
        function initGame() {
            const resizeCanvas = () => {
                // Make canvas fill the screen
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                
                // Update camera dimensions
                camera.width = canvas.width;
                camera.height = canvas.height;
                
                // Redraw non-game states immediately on resize
                if(gameStates.currentState !== gameStates.GAME) gameStates.draw();
                // For game state, the gameLoop will handle redraw
            };
            window.addEventListener('resize', resizeCanvas); 
            resizeCanvas(); // Initial resize

            // Set initial player position relative to Kremer's table (if tables are initialized)
            if (tables.length > KREMER_TABLE_INDEX && tables[KREMER_TABLE_INDEX]) {
                 player.x = tables[KREMER_TABLE_INDEX].x + tables[KREMER_TABLE_INDEX].width / 2;
                 player.y = tables[KREMER_TABLE_INDEX].y + tables[KREMER_TABLE_INDEX].height + TILE_SIZE * 2;
            } else { // Fallback if tables aren't ready (should not happen with current flow)
                player.x = WORLD_WIDTH / 2;
                player.y = WORLD_HEIGHT / 2;
            }
            player.targetX = player.x; player.targetY = player.y; // Sync target

            updateCamera(); // Initial camera setup
            gameStates.currentState = gameStates.MENU; // Start at the menu
            gameLoop(); // Start the game loop
        }
        window.addEventListener('load', initGame);
    </script>
</body>
</html>
